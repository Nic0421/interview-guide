## 一、CSS

### 1.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？

- 行内元素：a、span、img、input、strong、label、select、textarea、button
- 块级元素：div、p、h1-h6、ul、ol、li、dl、dt、dd、table、form
- 空元素：br、hr、img、input、link、meta
- 区别：
  - 布局：块级元素会占满更多的空间（通常是一整行），而行内元素只占用它们所需的空间。
  - 可嵌套性：块级元素可以包含行内元素和其他块级元素，但行内元素通常不能包含块级元素（尽管有些情况下可以，如在HTML5中，<a>可以包含块级元素）。
  - 默认行为：块级元素会在前后自动添加换行，而行内元素则不会。

### 2.说一下CSS的盒模型。

在HTML页面中的所有元素都可以看成是一个盒子
盒子的组成：内容content、内边距padding、边框border、外边距margin
盒模型的类型：
标准盒模型
margin + border + padding + content
IE盒模型
margin + content(border + padding)
控制盒模型的模式：box-sizing:content-box（默认值，标准盒模型）、
border-box（IE盒模型）

### 3.CSS选择器的优先级？

CSS的特性：继承性、层叠性、优先级
优先级：写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式
标签、类/伪类/属性、全局选择器、行内样式、id、!important
!important > 行内样式 > id > 类/伪类/属性 > 标签 > 全局选择器

::after ::befroe

### 4.所有CSS伪类/元素

| 选择器                                                              | 示例           | 示例说明                                        |
| ------------------------------------------------------------------- | -------------- | ----------------------------------------------- |
| [:link](https://www.runoob.com/cssref/sel-link.html)                | a:link         | 选择所有未访问链接                              |
| [:visited](https://www.runoob.com/cssref/sel-visited.html)          | a:visited      | 选择所有访问过的链接                            |
| [:active](https://www.runoob.com/cssref/sel-active.html)            | a:active       | 选择正在活动链接                                |
| [:hover](https://www.runoob.com/cssref/sel-hover.html)              | a:hover        | 把鼠标放在链接上的状态                          |
| [:focus](https://www.runoob.com/cssref/sel-focus.html)              | input:focus    | 选择元素输入后具有焦点                          |
| [:first-letter](https://www.runoob.com/cssref/sel-firstletter.html) | p:first-letter | 选择每个<p> 元素的第一个字母                    |
| [:first-line](https://www.runoob.com/cssref/sel-firstline.html)     | p:first-line   | 选择每个<p> 元素的第一行                        |
| [:first-child](https://www.runoob.com/cssref/sel-firstchild.html)   | p:first-child  | 选择器匹配属于任意元素的第一个子元素的 <p> 元素 |
| [:before](https://www.runoob.com/cssref/sel-before.html)            | p:before       | 在每个<p>元素之前插入内容                       |
| [:after](https://www.runoob.com/cssref/sel-after.html)              | p:after        | 在每个<p>元素之后插入内容                       |
| [:lang(language)](https://www.runoob.com/cssref/sel-lang.html)      | p:lang(it)     | 为<p>元素的lang属性选择一个开始值               |

### 5.隐藏元素的方法有哪些？

display:none; 元素在页面上消失，不占据空间
opacity:0;设置了元素的透明度为0，元素不可见，占据空间位置
visibility:hidden; 让元素消失，占据空间位置，一种不可见的状态
position:absolute; 脱离文档流
clip-path 剪切元素

### 4.px和rem的区别是什么？

```javascript
px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样，绝对单位长度
rem，相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%;
1rem = 10px; （16px*62.5%=10px）
```

### 5.重绘重排有什么区别？

![](https://cdn.nlark.com/yuque/__mermaid_v3/f5de10238fec2386558a00677cd16a91.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBMUlxuQVtIVE1MXSAtLSBIVE1MIFBhcnNlciAtLT4gQihET00gVHJlZSlcbkZbU3R5bGUgU2hlZXRzXSAtLSBDU1MgUGFyc2VyIC0tPiBDKENTUyBUcmVlKVxuQiAtLT4gRChSZW5kZXIgVHJlZSlcbkMgLS0-IERcbkQgLS0-IEUoUGFpbnRpbmcpIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fbWVybWFpZF92My9mNWRlMTAyMzhmZWMyMzg2NTU4YTAwNjc3Y2QxNmE5MS5zdmciLCJpZCI6ImU4YmFiNGViIiwiY2FyZCI6ImRpYWdyYW0ifQ==)```javascript
重排（回流）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小，修改字体大小
重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制
浏览器的渲染机制
对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排
对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘

````

### 6.让一个元素水平垂直居中的方式有哪些？

```javascript
1.定位+margin
2.定位+transform
3.flex布局
4.grid布局
5.table布局
````

```tsx
//相对+绝对
.father{
    postion:reletive;
    width:400px;
    height:400px;
}
.son{
    position:absolute;
    width:200px;
    height:200px;
    top:0;
    bottom:0;
    left:0;
    right:0;
    margin:auto;
}
// 相对+ transform
.father{
    width:400px;
    height:400px;
    position:reletive;
}
.son{
    position:absolute;
    width:200px;
    height:200px;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%)
}
//flex
.father{
    display:flex;
    justify-content:center;
    align-items:center;
    }
.son{
    width:200px;
    height:200px;
}
```

### 7.CSS的哪些属性哪些可以继承？哪些不可以继承？

```
    CSS的三大特性：继承、层叠、优先级
        子元素可以继承父类元素的样式
        1.字体的一些属性：font
        2.文本的一些属性：line-height
        3.元素的可见性：visibility:hidden
        4.表格布局的属性：border-spacing
        5.列表的属性：list-style
        6.页面样式属性：page
        7.声音的样式属性
```

### 8.有没有用过预处理器？

预处理语言增加了变量、函数、混入等强大的功能
       SASS  LESS

## 二、JavaSscipt

### 1.0 ts中 interface type的区别是？

在TypeScript中，interface和type都用来定义对象的结构，但它们有一些区别：

1. interface：

- interface用于定义对象的结构，可以包含**属性、方法、索引签名**等。
- interface可以被类实现（implement），对象可以通过实现接口来约束对象的结构。
- interface支持**扩展（extend）继承**，可以通过继承其他接口来扩展接口的定义。
- interface不能重复定义，如果多次定义同一个接口名，TypeScript会进行合并处理。
- 推荐在定义抽象结构时使用interface。

1. type：

- type用于定义数据类型，可以是**基本类型、联合类型、交叉类型等，也可以是对象类型**。
- type可以用于**定义联合类型、交叉类型、元组类型等**。
- type**不支持继承**，无法实现和扩展，一旦定义了就不能重复定义。
- type支持复杂的类型操作符（Type Operators），可以进行类型的转换、组合等操作。
- 推荐在定义简单数据类型、联合类型、交叉类型等时使用type。

总的来说，**interface更适合用来定义对象的结构和行为，而type更适合用来定义数据类型和进行类型操作**。在使用时根据具体情况选择合适的方式来定义类型。

### var let const的区别？

#### 一、let、const、var的区别

**（1）块级**[作用域](https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020)**： **块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：

- 内层变量可能覆盖外层变量
- 用来计数的循环变量泄露为[全局变量](https://so.csdn.net/so/search?q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020)

**（2）变量提升**： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。
**（3）给全局添加属性**： 浏览器的全局对象是window，[Node](https://so.csdn.net/so/search?q=Node&spm=1001.2101.3001.7020)的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。
**（4）重复声明**： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。
**（5）暂时性死区**： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。
**（6）初始值设置**： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。
（7）指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。

| **区别**           | **var** | **let** | **const** |
| ------------------ | ------- | ------- | --------- |
| 是否有块级作用域   | ×       | ✔️      | ✔️        |
| 是否存在变量提升   | ✔️      | ×       | ×         |
| 是否添加全局属性   | ✔️      | ×       | ×         |
| 能否重复声明变量   | ✔️      | ×       | ×         |
| 是否存在暂时性死区 | ×       | ✔️      | ✔️        |
| 是否必须设置初始值 | ×       | ×       | ✔️        |
| 能否改变指针指向   | ✔️      | ✔️      | ×         |

#### 二、const对象的属性可以修改吗

const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。
但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。

### 1.JS由哪三部分组成？

ECMAScript：JS的核心内容，描述了语言的基础语法，比如var,for，数据类型（数组、字符串），
       文档对象模型（DOM）：DOM把整个HTML页面规划为元素构成的文档
       浏览器对象模型（BOM）：对浏览器窗口进行访问和操作

### 2.JS有哪些内置对象？

```javascript
String Boolean Number Array Object Function
Math new Date RegExp...
Math数学对象
Math.abs 绝对值
Math.sprt 开平方
Math.max Math.min
Math.random()
//取得(n,m)范围随机数
function fullOpen(n,m) {
   let result = Math.random()*(m-n)+n;
   while(result == n) {
       result = Math.random()*(m-n)+n;
   }
   return result;
}
Math.round(num)：将 num 四舍五入取整
Math.floor(num)：将 num 向下取整，即返回 num 的整数部分。当然我们也可以使用 parseInt() 方法代替。
Date
new Date getYear()
Array
往下翻 操作数组的方法有哪些？
String
concat() length slice() split()
String.prototype.split()方法通过传入的参数符号，将一个字符串对象分割成一个字符串数组，这个传入的参数符号决定着字符串在什么位置进行分割。
String.prototype.slice()
var str="Hello world!";
var n=str.slice(1,5);// ello
```

### 3.操作数组的方法有哪些？

push() pop() sort() splice() unshift() shift() reverse() concat() join() map() filter()
       ervery() some() reduce() isArray() findIndex()
       哪些方法会改变原数组？
           push() pop() unshift() shift() sort() reverse() splice()

1.  **改变原始数组的操作方法:**

```javascript
1. push:向数组末尾添加元素，并返回新的长度
2. pop:删除最后一个并返回删除的元素
3. unshift:向数组开头添加元素，并返回新的长度
4. shift:将第一个元素删除并且返回删除元素，空即为undefined
5. reverse:颠倒数组顺序
6. sort:对数组排序
7. splice:删，增，替换数组元素，返回被删除数组，无除则不返回
```

2.  **不会改变原始数组的操作方法**

```javascript
1. concat:连接多个数组，返回新的数组ioin:将数组中所有元素以参数作为分隔符放入一个字符
2. slice:返回选定元素
3. map(es6):数组映射为新的数组
4. filter(es6):数组过滤，返回所有通过方法判断后(判断为true时)生成的新数组
5. forEach:数组遍历，没有返回值
6. every(es6):对数组中的每一项运行给定函数，如每一项均为true时返回true，否则返回false
7. some(es6):数组中的的元素运行给定函数，如其中有一项为true时返回true，此时剩余的元素不会再执行检测，如果所以都为false则返回false
8. find(es6):寻找数组中符合测试方法(函数)条件的第一个元素，并且返回该元素
9. reduce(es6):方法接收一个函数作为累加器，数组中的每个值(从左到右)开始缩减，最终计算为一个值
10. index0f:方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。
11. includes(es7):方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true,否则返回false。
```

### 4.数据类型检测方法有哪些？

- instanceof是一个用于判断一个对象是否是某个构造函数的实例的运算符，使用方式为：`object instanceof constructor`。**它的原理是通过检查object的原型链（prototype chain），看是否存在constructor的原型对象。如果存在，则返回true，否则返回false。**
- typeof是一个用于判断数据类型的运算符，使用方式为：`typeof operand`。它的原理是通过检查operand的类型信息，返回一个表示数据类型的字符串。常见的结果有："undefined"、"boolean"、"number"、"string"、"object"和"function"。instanceof和typeof的原理不同，它们用于不同的情况。
- instanceof主要用于判断对象是否是某个构造函数的实例，而typeof主要用于判断变量的数据类型。

```javascript
typeof() 基本数据类型 no 引用数据类型
typeof 'hello'; // 返回 "string"
typeof 123; // 返回 "number"
typeof true; // 返回 "boolean"
typeof undefined; // 返回 "undefined"
typeof function(){}; // 返回 "function"
typeof null; // 返回 "object"
优点：该方法简单、快速，适用于大多数情况下。
缺点：其中数组、对象、null 都会被判断为 object,无法判断复杂的数据类型如数组和正则表达式，其他判断都正确。
```

```javascript
instanceof() 引用数据类型，no 基本数据类型
console.log(2 intanceof Number)  // false
console.log( [] intanceof Array )  // true
优点：可以区分复杂的数据类型如数组和正则表达式。
缺点：无法判断基本数据类型，无法判断 null 和 undefined 类型。
```

```javascript
constructor 基本和引用都可以，如果声明了一个构造函数，并把原型指向了Array就不行了
 console.log(("abc").constructor===String) // true
constructor 有两个作用，一是判断数据的类型，二是对象实例通过
constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象
来改变它的原型，constructor 就不能用来判断数据类型了：
 function Fn(){}
  Fn.prototype = new Array();
  var f = new Fn()
  console.log( f.constructor === Fn )   // false
  console.log( f.constructor === Array )  //true

  优点：语法简单，只需访问变量的 constructor 属性即可判断。
  缺点：当变量被重新赋值时，可能会出现问题，无法判断 null 和 undefined 类型。
```

```javascript
Array.isArray()
Array.isArray() 方法可以用于判断变量是否为数组类型。
优点：语法简单，只需调用 Array.isArray() 方法即可判断。
缺点：只能判断数组类型，无法判断其他数据类型。
```

```javascript
Object.prototype.toString.call()
var a = Object.prototype.toString;
console.log(a.call(2))

优点：可以判断复杂的数据类型，包括数组、正则表达式等。
缺点：需要调用 Object.prototype.toString.call() 方法，语法较复杂
```

### 5.说一下闭包，闭包有什么特点？

```tsx
什么是闭包，
函数嵌套函数，内部函数被外部函数返回并保存下来，就会产生闭包
function fn(a){
    return funcion(){
        console.log(a)
    }
}
let fo = fn('abc')
fo()
特点：
可以重复利用变量，并且这个变量不会污染全局的一种机制。这个变量是一直保持在内存，不会被垃圾回收机制回收，需要手动设置null，
缺点：
闭包较多的时候，会消耗内存，导致页面性能下降，在IE浏览器中会导致内存泄漏
使用场景：
防抖，节流，函数嵌套，避免全局污染的时候
防抖--------------------
function debounce(func, delay) {
  let timerId;
  return function(...args) {
    if (timerId) {
      clearTimeout(timerId);
    }
    timerId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}
// 使用例子
const debouncedFunction = debounce(() => {
  console.log("防抖函数被触发");
}, 300);

window.addEventListener("scroll", debouncedFunction);
节流--------------------
function throttle(func, delay) {
  let throttled = false;
  return function(...args) {
    if (!throttled) {
      throttled = true;
      setTimeout(() => {
        func.apply(this, args);
        throttled = false;
      }, delay);
    }
  };
}

// 使用例子
const throttledFunction = throttle(() => {
  console.log("节流函数被触发");
}, 300);

window.addEventListener("scroll", throttledFunction);
```

### 6.前端的内存泄漏怎么理解？

JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。
       垃圾回收机制
       因素：一些为生命直接赋值的变量；一些未清空的定时器；过度的闭包；一些引用元素没有被清除。

### 7.事件委托是什么？

又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上
       如果子元素组织了事件冒泡，那么委托也就不成立
       组织事件冒泡：event.stopPropagation()
       addEventListener('click',函数名，true/false) 默认是false（事件冒泡），true（事件捕获）
       好处：提高性能，减少事件的绑定，也就减少了内存的占用。

### 8.基本数据类型和引用数据类型的区别？

```javascript
基本数据类型：string number boolean undefind null 保存在栈内存 保存的是一个具体的值

---symbol：ES6引入了Symbol，它为原始数据类型，表示独一无二的值
---BigInt是ES11引入的新的基本数据类型。BigInt数据类型的目的是比Number数据类型支持的范围更大的整数值，以任意精度表示整数。使用 BigInt解决了之前Number整数溢出的问题。
let max = Number.MAX_SAFE_INTEGER;//Number的最大安全整数
console.log(max);
console.log(max + 1);
//超过number的最大数值范围，运算就会出错
console.log(max + 2);

console.log(BigInt(max));
//BigInt数据类型不能直接和普通数据类型进行运算
console.log(BigInt(max) + BigInt(1));
console.log(BigInt(max) + BigInt(2));

引用数据类型：Object Function Array 正则 日期对象new Date 保存在堆内存 保存的只是引用类型数据的一个地址

假如申明2个引用类型，同时指向了一个地址的时候，修改其中一个，那么另一个也会改变。
```

新的有BigInt 超长整数
Symbol 独一无二的值

### 9.说一下原型链。

原型就是一个普通对象，它是为构造函数的**实例**共享属性和方法；所有实例中引用的原型都是同一个对象，**共享实例new A 上的方法和属性，**
       使用prototype可以把方法挂在原型上，内存值保存一份
       --**proto-- **可以理解为指针，实例对象中的属性，指向了构造函数的原型（prototype）
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712714763506-f41c85e1-963e-4d98-b00c-1aac72991524.png#averageHue=%23fdfdfd&clientId=u700e487e-5acc-4&from=paste&height=239&id=u04d6d4a1&originHeight=358&originWidth=1075&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=113044&status=done&style=none&taskId=u33db525e-b8f2-4c33-b3a6-bf173a1a239&title=&width=716.6666666666666)
一个实例对象在调用属性和方法的时候，会依次从实例本身，构造函数原型，原型的原型上去查找，这种就叫原型链 最后是null
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712714782743-721704ed-eb2a-48dc-b758-9467b7bfce39.png#averageHue=%23fefdfd&clientId=u700e487e-5acc-4&from=paste&height=278&id=ubd86e564&originHeight=417&originWidth=883&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=88568&status=done&style=none&taskId=uc05c909e-079a-4b79-8d07-8ee0b708f31&title=&width=588.6666666666666)

### 10.new操作符具体做了什么？

1.先创建一个空对象
       2.把空对象和构造函数通过原型链进行链接
       3.把构造函数的this绑定到新的空对象身上
       4.根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型

```javascript
function newFun(Fun, ...arg) {
  // 先创建一个空对象
  const newObj = {}
  // 2. 把空对象和构造函数通过原型链进行连接
  newObj.__proto__ = Fun.prototype
  // 3. 把构造函数的this指针，绑定到新的空对象的身上
  const result = Fun.apply(newObj, arg)
  // 4. 根据构建函数返回的数据类型，判断
  // 如果是值类型，则返回对象，
  // 如果是引用类型则返回引用类型
  return result instanceof Object ? result : newObj
}

function Person(name) {
  this.name = name
}
Person.prototype.say = function () {
  console.log('1234')
}
const p1 = newFun(Person, '2234')
p1.say()
console.log(p1)
```

### 11.JS是如何实现继承的？

1.原型链继承
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712714814147-3a89c42c-8511-4368-8645-9dc531621961.png#averageHue=%23fbfbfb&clientId=u700e487e-5acc-4&from=paste&height=443&id=u62579841&originHeight=664&originWidth=1023&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=361946&status=done&style=none&taskId=ub4c269dc-aca5-4c76-9662-1b603e3b1f7&title=&width=682)
       2.借用构造函数继承
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712714825064-f74e6ffa-75dc-45c3-a07f-8c7a4678681a.png#averageHue=%23fcfcfc&clientId=u700e487e-5acc-4&from=paste&height=394&id=uf72e8fb8&originHeight=591&originWidth=1041&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=345537&status=done&style=none&taskId=u34bd4514-2ac6-4c81-baf9-67ffd526f9e&title=&width=694)
       3.组合式继承
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712714835595-2cbdfe97-7ba3-43b3-b6c6-4fb206dbf8a1.png#averageHue=%23fdfdfd&clientId=u700e487e-5acc-4&from=paste&height=526&id=u777ac506&originHeight=789&originWidth=960&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=359569&status=done&style=none&taskId=ua339f25d-f963-4717-a569-1465645bd2a&title=&width=640)
       4.ES6的class类继承
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712714843685-6a14b2fc-cc91-4870-97f1-f2e98d34f595.png#averageHue=%23fdfdfd&clientId=u700e487e-5acc-4&from=paste&height=530&id=uced9cd19&originHeight=795&originWidth=970&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=394805&status=done&style=none&taskId=u3c5e1a17-40d9-4baf-a8f8-cc95c9190d9&title=&width=646.6666666666666)

### 12.JS的设计原理是什么？

** JS引擎 运行上下文 调用栈 事件循环 回调**
JS引擎 V8引擎 对js进行编译就算是，浏览器引擎
运行上下文：浏览器的API window 任务队列
调用栈: js是单线程
事件循环： 当调用栈内容空了以后 把任务会放到调用栈去循环
回调函数：callback 加入到任务队列，

总结：**js 将现调用栈中的所有同步任务，按照上下文的顺序执行，遇到异步任务就会依次加入任务队列，在同步任务执行完成之后，循环从任务队列中，依次取出异步任务到调用栈中执行，**
异步任务又分为宏任务和微任务
宏任务（macrotask）和微任务（microtask）都涉及到 JavaScript 中的异步执行。

**宏任务**（macrotask）指的是由浏览器发起的任务，比如用户交互、定时器事件、网络请求等。在事件循环的每一轮中，只会执行一个宏任务。

常见的宏任务包括：

- setTimeout
- setInterval
- setImmediate（Node.js 环境中）
- I/O 操作
- UI 渲染

**微任务**（microtask）则是相对于宏任务来说更小粒度的任务，它们在宏任务执行完之后立即执行，即使在当前宏任务执行过程中产生的微任务也会在本轮事件循环的末尾执行。

常见的微任务包括：

- Promise 的回调函数 Promse.then才是
- MutationObserver
- process.nextTick（Node.js 环境中）

下面是一个简单的例子来说明宏任务和微任务的执行顺序：

```javascript
console.log('script start')

setTimeout(() => {
  console.log('setTimeout')
}, 0)

Promise.resolve()
  .then(() => {
    console.log('promise1')
  })
  .then(() => {
    console.log('promise2')
  })

console.log('script end')
```

这段代码中，先输出'script start'，然后输出'script end'。接着，微任务中的 Promise 回调函数会被执行，输出'promise1'和'promise2'。最后，宏任务中的 setTimeout 回调函数会被执行，输出'setTimeout'。

情况区分，如果在宏任务队列中有 微任务，则先执行宏，如果宏任务和微任务是平级的，则先执行微任务

##### 优先级：同步任务>异步任务>微任务>宏任务>**（宏任务里面的微任务）**

### 13.JS中关于this指向的问题

1. 全局对象中的this指向
              指向的是window
          2. 全局作用域或者普通函数中的this
              指向全局window
          3. this永远指向最后调用它的那个对象
              在不是箭头函数的情况下
          4. new 关键词改变了this的指向
          5. apply,call,bind
              可以改变this指向，不是箭头函数
          6. 箭头函数中的this
              它的指向在定义的时候就已经确定了
              箭头函数它没有this,看外层是否有函数，有就是外层函数的this，没有就是window
          7. 匿名函数中的this
              永远指向了window,匿名函数的执行环境具有全局性，因此this指向window

### 14.script标签里的async和defer有什么区别？

**当没有async and defer标签属性的时候**，浏览器会立即加载并执行指定的脚本
**有async的时候**，加载和渲染后面元素的过程将和script的加载和执行，并行进行（异步）
**有defer的时候**，加载和渲染后面元素的过程将和script的加载，并行进行（异步），但是他的执行时间，需要等所有元素解析完成之后，才会执行

### settimeout的内部实现原理？

基本原理是通过 JavaScript 的事件循环（Event Loop）来实现的。
当你调用 setTimeout 函数时，它会接收两个参数：一个函数（或代码块）和一个表示延迟时间的毫秒数。在指定的延迟时间之后，事件循环会将该函数放入到任务队列（Task Queue）中。
事件循环的工作原理是不断地从任务队列中取出任务执行，然后再取下一个任务，如此循环。这就意味着 setTimeout 中的延迟时间并不是精确的，而是表示至少需要等待指定的毫秒数。
以下是 setTimeout 工作原理的简化步骤：

1. 当调用 setTimeout 时，它会被放入到调用栈（Call Stack）中。
2. setTimeout 会向浏览器请求创建一个定时器，并设置一个延迟时间。
3. 调用栈中的其他任务继续执行。
4. 当指定的延迟时间过去后，定时器会把回调函数放入到任务队列（Task Queue）中。
5. 事件循环不断地从任务队列中取出任务，执行它们。

需要注意的是，由于 JavaScript 是单线程的，所以 setTimeout 中的代码实际上是在主线程上执行的。这意味着如果在 setTimeout 的延迟期间有其他代码阻塞了主线程，那么 setTimeout 中的回调函数会等待主线程空闲时才执行。
这就是 setTimeout 的基本工作原理。

### 循环遍历数组，你用过那些？

1. **for 循环**：最基本的循环方法，可以通过索引来访问数组的每个元素。

```
let arr = [10, 20, 30, 40];
for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}
```

2. **for...of 循环**：ES6 引入的新循环语法，可以直接遍历数组的元素而不是索引。

```
let arr = [10, 20, 30, 40];
for (let value of arr) {
    console.log(value);
}
```

3. **forEach() 方法**：数组的内置方法之一，为数组中的每个元素执行一次提供的函数。

```
let arr = [10, 20, 30, 40];
arr.forEach(function(value, index) {
    console.log(value);
});
```

4. **map() 方法**：和 forEach() 类似，但 map() 会创建一个新数组，其中的元素是原始数组元素调用函数处理后的值。

```
let arr = [1, 2, 3, 4];
let squares = arr.map(x => x * x);
console.log(squares); // 输出: [1, 4, 9, 16]
```

5. **reduce() 方法**：适用于累积运算，比如计算数组中所有元素的总和。

```
let arr = [1, 2, 3, 4];
let sum = arr.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
console.log(sum); // 输出: 10
```

6. **filter() 方法**：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。

```
let arr = [1, 2, 3, 4, 5, 6];
let evenNumbers = arr.filter(x => x % 2 === 0);
console.log(evenNumbers); // 输出: [2, 4, 6]
```

这些方法中，for 和 for...of 循环提供了更多的控制力（例如，可以使用 break 或 continue），而像 forEach、map、reduce 和 filter 这样的数组方法则更适合函数式编程风格。根据需要选择合适的方法可以使代码更简洁、更易于维护。
用**迭代器**来遍历数组的示例：

```
let arr = [10, 20, 30, 40];

// 获取迭代器对象
let iterator = arr[Symbol.iterator]();

// 使用迭代器遍历数组
let next = iterator.next();
while (!next.done) {
    console.log(next.value);
    next = iterator.next();
}
```

在这个示例中，我们首先通过 arr[Symbol.iterator]() 获取了数组 arr 的迭代器对象，然后使用 next() 方法来遍历数组，直到 next() 方法返回的对象中的 done 属性为 true，表示迭代结束。
虽然直接使用 for...of 循环更简洁，但了解如何使用迭代器来手动遍历数组也是很有用的，特别是当你需要更多的控制权或者想要深入理解迭代器的工作原理时。

### 15.setTimeout最小执行时间是多少？

HTML5规定的内容：
           setTimeout最小执行时间是4ms
           setInterval最小执行时间是10ms

### 16.ES6和ES5有什么区别？

JS的组成：ECMAScript BOM  DOM
       ES5:ECMAScript5,2009年ECMAScript的第五次修订，ECMAScript2009
       ES6:ECMAScript6,2015年ECMAScript的第六次修订，ECMAScript2015，是JS的下一个版本标准

### 17.ES6的新特性有哪些？

1.新增块级作用域（let,const）
           不存在变量提升
           存在暂时性死区的问题
           块级作用域的内容
           不能在同一个作用域内重复声明
       2.新增了定义类的语法糖（class）
       3.新增了一种基本数据类型（symbol）
       4.新增了解构赋值
           从数组或者对象中取值，然后给变量赋值
       5.新增了函数参数的默认值
       6.给数组新增了API

1.  Array.of
    Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载！因为Array方法没有参数、一个参数、二个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度！而Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。

```javascript
[] // []
Array(5)[(1, 5)] // [empty × 5] // [1, 5]

Array.of() // []
Array.of(5) // [5]
Array.of(1, 5) // [1, 5]
```

2.  Array.fill
    fill方法可以接三个参数，有一个参数时为给定值，填充一个数组！

```javascript
[1, 2, 3].fill(9) // [9, 9, 9]
Array.from({ length: 3 }).fill(9) // [9, 9, 9]
```

有二个参数的时候，第一个参数是给定的填充的值，第二个参数是填充的起始位置！

```javascript
[1,2,3].fill(9,1)//[1, 9, 9]
new Array(3).fill(9,1))//[empty, 9, 9]
```

有三个参数的时候，第一个参数是给定的填充的值，第二个参数是填充的起始位置，第三个参数是填充结束位置！

```javascript
[1, 2, 3, 4, 5, 6].fill(9, 1, 4) // [1, 9, 9, 9, 5, 6]
```

注意：上面代码表示，fill方法从 1 号置位开始，向原数组填充 9，到 4 号位置之前结束（不包括4号位置）！

3.  Array.from
    Array.from方法用于将两类对象转为真正的数组，一：伪数组的对象（类似dom元素，arguments对象），二：可遍历的对象（包括 ES6 新增的数据结构 Set 和 Map）

```javascript
const a = {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
}
const div = document.querySelectorAll('div')
console.log(Array.from(a)) // [1,2,3]
console.log(Array.from(div))
console.log(Array.from(new Set([1, 2, 3, 4]))) // [1,2,3,4]
```

Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组

```javascript
Array.from([1, 2, 3], item => item * item) // [1,4,9]
```

如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。

```javascript
Array.from(
  [1, 2, 3],
  function (x) {
    return x * this.y
  },
  {
    x: 1,
    y: 2,
  }
) // [2, 4, 6]
```

4.  Array.flat
    此方法可以将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响！flat()的参数为几，表示要“拉平”几层的嵌套数组，如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。

```javascript
[1, 2, 3, [4, 5]].flat(); // [1, 2, 3, 4, 5]
[1, 2, 3, [[3, 4], 5]].flat(2); // [1, 2, 3, 3, 4, 5]
[
  1,
  2,
  3,
  [
    [3, 4],
    [5, [7, 8]],
  ],
].flat(Number.POSITIVE_INFINITY) // [1, 2, 3, 3, 4, 5, 7, 8]
```

5.  Array.flatMap
    flatMap()对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。

```javascript
[1, 2, 3].flatMap(x => [x * 1, x * 2]) // [1, 2, 2, 4, 3, 6]
```

flatMap()只能展开一层数组。

```javascript
[1, 2, 3].flatMap(x => [[x * 1, x * 2]]) // [[1,2],[2,4],[3,6]]
```

flatMap()方法的第一个参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组，第二个参数，用来绑定遍历函数里面的this。

```javascript
const arr = [1, 2, 3, 4, 5].flatMap(
  function (item, index, arr) {
    return [[item * this.y]]
  },
  {
    x: 1,
    y: 2,
  }
)
console.log(arr) // [[2],[4],[6],[8],[10]]
```

6.  Array.copyWithin
    target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
    start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
    end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。

```javascript
// 取索引为2到数组结束的值(3,4,5)，放到索引为0的位置
[1, 2, 3, 4, 5]
  .copyWithin(0, 2) // [3, 4, 5, 4, 5]
  [
    // -1为数组的length-1位置（5），-3就是3，那么就是3,4放到数组索引为0的位置
    (1, 2, 3, 4, 5)
  ].copyWithin(0, -3, -1) // [3,4,3,4,5]
```

7.  entries()，keys() 和 values()
    entries()，keys()和values()都用于遍历数组。但是它们都返回一个遍历器对象，keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历,并且要调用遍历器对象的next方法，然后取value值（有点繁琐！）

```javascript
const arr = [1, 2, 3]
const entries = arr.entries()
console.log(entries.next().value) // [0,1]
console.log(entries.next().value) // [1,2]
console.log(entries.next().value) // [2,3]
```

或者直接用for of,这种方法会简单点

```typescript
const arr = [1, 2, 3]
for (const item of arr.entries()) console.log(item)

// [0,1] [1,2] [2,3]

for (const item of arr.keys()) console.log(item)

// 0 1 2
for (const item of arr.values()) console.log(item)

// 1 2 3
```

7.对象和数组新增了扩展运算符
       8.Promise
           解决回调地狱的问题。
           自身有all,reject,resolve,race方法
           原型上有then,catch
           把异步操作队列化
           三种状态：pending初始状态,fulfilled操作成功,rejected操作失败
           状态：pending -> fulfilled;pending -> rejected 一旦发生，状态就会凝固，不会再变
           async  await
               同步代码做异步的操作，两者必须搭配使用
               async表明函数内有异步操作，调用函数会返回promise
               await是组成async的表达式，结果是取决于它等待的内容，如果是promise那就是promise的结果，如果是普通函数就进行链式调用
               await后的promise如果是reject状态，那么整个async函数都会中断，后面的代码不执行

8.

![](https://cdn.nlark.com/yuque/__mermaid_v3/3d790ee7d7e5a109290700c540b1107a.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBMUlxuRSgoUHJvbWlzZSkpIC0t54q25oCB5Yed5Zu6LS0-IEZ7UGVuZGluZ30gLS3miJDlip8tLT4gRyhmdWxmaWxsZWQpXG5Ge1BlbmRpbmd9IC0t5aSx6LSlLS0-IEgocmVqZWN0ZWQpIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fbWVybWFpZF92My8zZDc5MGVlN2Q3ZTVhMTA5MjkwNzAwYzU0MGIxMTA3YS5zdmciLCJpZCI6IjhhMjkwMDM5IiwiY2FyZCI6ImRpYWdyYW0ifQ==)
   9.新增了模块化（import,export）
   10.新增了set和map数据结构
       set就是不重复
       map的key的类型不受限制
   11.新增了generator
   12.新增了箭头函数
       不能作为构造函数使用，不能用new
       箭头函数就没有原型
       箭头函数没有arguments
       箭头函数不能用call,apply,bind去改变this的执行
       this指向外层第一个函数的this 13.新增了模版字符串 `${}`
14.proxy generator

### 18.call,aply,bind三者有什么区别？

都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同
   call方法传的是一个参数列表
   apply传递的是一个数组
   bind传参后不会立刻执行，会返回一个改变了this指向的函数，这个函数还是可以传参的，bind()()
   call方法的性能要比apply好一些，所以call用的更多一点

### 19.用递归的时候有没有遇到什么问题？

如果一个函数内可以调用函数本身，那么这个就是递归函数
   函数内部调用自己
   特别注意：写递归必须要有退出条件return

1.

```javascript
const json = [
  {
    id: 1,
    title: '课程1',
    children: [
      { id: 4, title: '课程1-1' },
      {
        id: 5,
        title: '课程1-2',
        children: [
          { id: 6, title: '课程1-2-1' },
          { id: 7, title: '课程1-2-2' },
        ],
      },
    ],
  },
  { id: 2, title: '课程2' },
  { id: 3, title: '课程3' },
]
let arr = []

function fn(j) {
  j.forEach((item) => {
    arr.push(item)
    // 循环判断是否有children
    if (item.children) {
      // 如果有 递归去除
      fn(item.children)
    }
  })
  // console.log(1)
  console.log('arr', JSON.stringify(arr))
  // debugger
  arr.forEach((item) => {
    // 删除children
    delete item.children
  })
  //
}
fn(json)
// 数字拍平
var arr = [1, 2, [3, 4, 5, [6, 7, 8], 9], 10, [11, 12]]
function fn(arr) {
  let arr1 = []
  arr.forEach((val) => {
    if (Array.isArray(val)) {
      console.log(1)
      arr1 = arr1.concat(fn(val))
    }
    else {
      arr1.push(val)
    }
  })
  return arr1
}
fn(arr)
// or
function fn(arr) {
  return arr.reduce((prev, cur) => {
    return prev.concat(Array.isArray(cur) ? fn(cur) : cur)
  }, [])
}
// or
const arr2 = arr.flat(Number.POSITIVE_INFINITY)
```

### 20.如何实现一个深拷贝？

深拷贝就是完全拷贝一份新的对象，会在堆内存中开辟新的空间，拷贝的对象被修改后，原对象不受影响
   主要针对的是引用数据类型
   1. 扩展运算符 **缺点：只能实现第一层的，一维的对象是可以实现，多维内部会修改原数组的值**
   2.JSON.parse(JSON.stringify()) **缺点：该方法，并不能拷贝内部函数 ,一维的对象是可以实现，多维内部会修改原数组的值**
   3.利用递归函数实现4.原生api structuredClone

```javascript
const obj = {
  name: '张三',
  age: 18,
  arr: {
    a: 111,
    b: 222,
  },
  say() {
    console.log('say Hello')
  },
  shen: [
    [1, 2],
    [3, 4, [5, 6]],
  ],
}
// 1. 扩展运算符
const obj1 = { ...obj }
obj1.name = '王五'
obj1.arr.a = '444'
// console.log(obj,obj1)
// 缺点：只能实现第一层的，一维的对象是可以实现，多维内部会修改原数组的值
// 2. JSON.parse(JSON.stringify())
const obj2 = JSON.parse(JSON.stringify(obj))
obj2.arr.a = '444'
// console.log(obj,"/n/r",obj2)
// 缺点：该方法，并不能拷贝内部函数 ,一维的对象是可以实现，多维内部会修改原数组的值
// 3. 利用递归来实现
function exten(origin, deep) {
  let obj = {}
  if (Array.isArray(origin))
    obj = []

  for (const key in origin) {
    const val = origin[key]
    obj[key]
      = !!deep && typeof value === 'object' && val !== null
        ? exted(val, deep)
        : val
  }
  return obj
}
const obj3 = exten(obj, true)
obj3.shen[0].push(888)
console.log(obj, obj3)
```

```javascript
const json = [
  {
    id: 1,
    title: '课程1',
    children: [
      { id: 4, title: '课程1-1' },
      {
        id: 5,
        title: '课程1-2',
        children: [
          { id: 6, title: '课程1-2-1' },
          { id: 7, title: '课程1-2-2' },
        ],
      },
    ],
  },
  { id: 2, title: '课程2' },
  { id: 3, title: '课程3' },
]
let arr = []

function fn(j) {
  j.forEach((item) => {
    arr.push(item)
    // 循环判断是否有children
    if (item.children) {
      // 如果有 递归去除
      fn(item.children)
    }
  })
  // console.log(1)
  console.log('arr', JSON.stringify(arr))
  // debugger
  arr.forEach((item) => {
    // 删除children
    delete item.children
  })
  //
}
fn(json)
// 数字拍平
var arr = [1, 2, [3, 4, 5, [6, 7, 8], 9], 10, [11, 12]]
function fn(arr) {
  let arr1 = []
  arr.forEach((val) => {
    if (Array.isArray(val)) {
      console.log(1)
      arr1 = arr1.concat(fn(val))
    }
    else {
      arr1.push(val)
    }
  })
  return arr1
}
fn(arr)
// or
function fn(arr) {
  return arr.reduce((prev, cur) => {
    return prev.concat(Array.isArray(cur) ? fn(cur) : cur)
  }, [])
}
// or
const arr2 = arr.flat(Number.POSITIVE_INFINITY)
```

### 21.说一下事件循环。

JS是一个单线程的脚本语言
   主线程 执行栈 任务队列  宏任务 微任务
   主线程先执行同步任务，然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务
   全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环！
![](https://cdn.nlark.com/yuque/__mermaid_v3/867e42338a5f9934f1fc27e04ad2308c.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBMUlxuQSgo5Li757q_56iLKSkgLS0g5LyY5YWI5omn6KGMIC0tPiBCe-S7u-WKoeexu-Wei31cbkIgLS0-IEMo5ZCM5q2l5Lu75YqhKVxuQiAtLT4gRCjlvILmraXku7vliqEpXG5EIC0tPiBFe-W8guatpeS7u-WKoeexu-Wei31cbkUgLS0-IEkoKOW-ruS7u-WKoSkpXG5JIC0tPiBKKCjlro_ku7vliqEpKVxuRSAtLT4gRigo5a6P5Lu75YqhKSlcbkYgLS0-IEd75piv5ZCm5YyF5ZCr5b6u5Lu75YqhfVxuRyAtLSDmnIkgLS0-IEso5YWI5a6P5ZCO5b6uKVxuRyAtLSDml6AgLS0-IEwo5a6P5Lu75YqhKVxuSyAtLT4gVyhFbmQpXG5MIC0tPiBXXG5KIC0tPiBXXG5XIC0t5LqL5Lu25b6q546vLS3kuIvkuIDkuKrku7vliqHpmJ_liJctLT4gRCIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX21lcm1haWRfdjMvODY3ZTQyMzM4YTVmOTkzNGYxZmMyN2UwNGFkMjMwOGMuc3ZnIiwiaWQiOiJiNWE5YTM1NyIsImNhcmQiOiJkaWFncmFtIn0=)
解释：

**主线程**先执行**同步任务**，然后才去执行**任务队列**里的任务，如果在执行宏任务之前有**微任务**，那么要先执行**微任务**

全部执行完后，等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务
情况区分，如果在宏任务队列嵌套了 微任务，则先执行宏，
如果宏任务和微任务是平级的，则先执行微任务优先级：
**同步任务>异步任务>微任务>宏任务>（宏任务里面的代码）>（宏任务里面的微任务代码）**

最先执行同步任务，然后执行异步任务，

异步任务分为多种情况，

1. **微任务在宏任务之前，则2个平级，按从上到下执行，先微后宏**
2. **宏任务在微任务之前，则先微任务，再宏任务，**
3. **宏任务内部有微任务，先执行宏任务里面的代码，再执行微任务的代码**

### 22.ajax是什么？怎么实现的？

创建交互式网页应用的网页开发技术
       在不重新加载整个网页的前提下，与服务器交换数据并更新部分内容
   通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过JS操作DOM更新页面
   1.创建XmlHttpRequest对象 xmh
   2.通过xmh对象里的open()方法和服务器建立连接
   3.构建请求所需的数据，并通过xmh对象的send()发送给服务器
   4.通过xmh对象的onreadystate chansge事件监听服务器和你的通信状态
   5.接收并处理服务器响应的数据结果
   6.把处理的数据更新到HTML页面上

```javascript
function sendRequest(method, url, data, callback) {
  // 创建一个xhr的实例
  const xhr = new XMLHttpRequest()
  // 通过xhr对象的open方法与服务器建立连接
  xhr.open(method, url, true)
  // 设置请求头类型
  xhr.setRequestHeader('Content-Type', 'application/json')
  // 通过xhr的onreadystatechange事件监听服务器和你的通信状态
  xhr.onreadystatechange = function () {
    if (xhr.readyState === XMLHttpRequest.DONE) {
      if (xhr.status >= 200 && xhr.status < 300) {
        const responseData = JSON.parse(xhr.responseText)
        // 接收并处理服务器响应的数据结果
        callback(null, responseData)
      }
      else {
        // 异常数据的处理
        callback(new Error(`Request failed with status ${xhr.status}`))
      }
    }
  }
  xhr.onerror = function () {
    callback(new Error('Request failed'))
  }
  // 构建请求所需的数据，并通过send方法发送给服务器
  xhr.send(JSON.stringify(data))
}
// 把处理好的数据更新到html页面上
// 示例用法：
const requestData = { key: 'value' }
sendRequest(
  'POST',
  'https://api.example.com/endpoint',
  requestData,
  (error, response) => {
    if (error)
      console.error('Error:', error)
    else console.log('Response:', response)
  }
)
```

### 23.get和post有什么区别？

1.get一般是获取数据，post一般是提交数据
   2.get参数会放在url上，所以安全性比较差，post是放在body中
   3.get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据
   4.get请求时会被缓存,post请求不会被缓存
   5.get请求会被保存在浏览器历史记录中,post不会
   6.get请求只能进行url编码，post请求支持很多种

### 24.promise的内部原理是什么？它的优缺点是什么？

Promise对象，封装了一个异步操作并且可以或者成功或者失败的结果，主要是为了解决回调地狱的
Promise是解决回调地狱的问题，之前如果异步请求较多，且他们之间有相互依赖的关系，就只能只用回调函数
这就容易形成回调地狱，且代码可读性和可维护性都很差。
有三种状态 pedding初始状态 fulfilled rejected
状态一旦凝固，则不可改变，只有fulfilled 成功和rejected失败
**缺点：**无法取消，一旦创建就会立即执行，不能中至
如果不设置回调，promise内部的异常不会反馈。
若当前处于pedding状态，无法得知目前在那个阶段。
**原理：** 构造一个promise实例，实例需要传递函数的参数，这个函数会有2个形参，且都是函数类型，resolve,reject
promise上then和catch，then是resolve的回调，catch是reject的回调函数
**finally: 不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。**

1. promise.all 接收的promise实例数组，总是按顺序且同步执行并返回的；只要有一个promise失败,最终状态就是失败的（reject）就会被catch捕获。
2. all返回的是一个promise的实例数组，返回结果也是一个数组
3. promise.race 也接收promise数组，总是返回执行最快的那一个，其他promise的状态并不关心。

### 25.promise和async await的区别是什么？

1.都是处理异步请求的方式
   2.promise是ES6，async await 是ES7的语法
   3.async await是基于promise实现的，他和promise都是非阻塞性的
   优缺点：
   1.promise是返回对象我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await 是通过tra catch进行捕获异常
   2.async await最大的优点就是能让代码看起来像同步一样，只要遇到await就会立刻返回结果，然后再执行后面的操作
   promise.then()的方式返回，会出现请求还没返回，就执行了后面的操作

### 26.浏览器的存储方式有哪些？

1.cookies
       H5标准前的本地存储方式
       兼容性好，请求头自带cookie
       存储量小，资源浪费，使用麻烦（封装）
   2.localstorage
       H5加入的以键值对为标准的方式
       操作方便，永久存储，兼容性较好
       保存值的类型被限定，浏览器在隐私模式下不可读取，不能被爬虫
   3.sessionstorage
       当前页面关闭后就会立刻清理，会话级别的存储方式
   4.indexedDB
       H5标准的存储方式，，他是以键值对进行存储，可以快速读取，适合WEB场景

```
1. cookies
   1. H5标准前的本地存储方式
   2. 兼容性好，请求体自带cookies
   3. 存储量小，资源浪费，使用麻烦需要封装，如cookies.js
2. localStroge
   1. H5新增的以键值对存储的方式
   2. 操作方便，永久存储，兼容性较好
   3. 保存值的类型被限定，浏览器在隐私模式下不可读取，不会被爬虫
3. sessionStroge
   1. 当前页面关闭后，自动销毁，会话级别的存储方式
4. indexDB
   1. H5的标准存储方式，也是键值对进行存储，可以快速读取，适合web场景
```

### 27.token存在sessionstorage还是loaclstorage？

token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串
   1.存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台
   2.存cookie【4-5kb】中，会自动发送，缺点就是不能跨域
   如果存在localstorage【5MB】中，容易被XSS攻击，但是如果做好了对应的措施，那么是利大于弊
   如果存在cookie中会有CSRF攻击

### 28.token的登录流程。

```
1. 客户端用账户密码请求登录
2. 服务器收到请求，需要验证账号密码
3. 验证成功之后，服务端会签发一个token，发给客户端
4. 客户端收到token保存到cookies 或者localstroge
5. 客户端每次请求都需要携带token
6. 服务端请求接着去验证客户端发送过来的token，验证成功才会返回客户端请求的数据
```

### 29.页面渲染的过程是怎样的？浏览器输入URL之后会发生什么

```
1. DNS解析 域名找到对应的服务器，
2. 然后与建立TCP连接
3. 发送http请求
4. 服务器处理请求
5. 渲染页面
   1. 浏览器会获取html和css的资源，然后会把html解析成DOM树
   2. 再把css 解析成cssom
   3. 再把dom 树和CSSOM合并为渲染树【render Tree】
   4. 布局 每个元素的位置大小颜色等
   5. 把渲染树的每个节点渲染到屏幕上【绘制】

6.断开TCP连接
```

### TCP 三次握手和四次握手

#### 三次握手

第一次握手：客户端向服务端发送包含自身初始序号 x 的同步报文，进入 SYN-SENT 状态。
第二次握手：服务端收到连接请求报文段后，会将连接放入半连接队列中，并向客户端发送包含自身初始序号 y 的同步确认报文，进入 SYN-RECEIVED 状态。
第三次握手：客户端收到应答，向服务端发送确认报文，进入 ESTABLISHED 状态，此时成功建立长连接。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1713754419186-7a5b89c7-2b62-419a-87e8-befaaa95952a.png#averageHue=%23d4ddb2&clientId=u7fac7363-56d8-4&from=paste&height=470&id=ubf3f8d1a&originHeight=705&originWidth=1072&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=599789&status=done&style=none&taskId=u2dfa2742-0476-4013-a2c9-981bffa7fd9&title=&width=714.6666666666666)

#### 四次挥手

第一次挥手：客户端数据发送完毕，向服务端发送终止报文请求释放连接。
第二次挥手：服务器收到连接释放请求，告诉应用层释放 TCP 连接。然后发送确认报文，进入 CLOSE-WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接受客户端的数据。但因为 TCP 是全双工的，所以服务器仍可以发送数据。
第三次挥手：当服务端数据发送完毕，向客户端发送终止报文，发送连接释放请求，进入 LAST-ACK 状态。
第四次挥手：客户端收到连接释放请求，向服务器端发送 确认报文，此时客户端进入 TIME-WAIT 状态，会等待 2MSL（最长报文段寿命），若期间没有收到服务器端的数据报文，进入 CLOSED 状态。服务器端在收到确认应答后也进入 CLOSED 态。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1713754433471-92d7424a-6544-4d92-a758-e2aac823eee9.png#averageHue=%23dce1b7&clientId=u7fac7363-56d8-4&from=paste&height=578&id=ubfc091cc&originHeight=867&originWidth=1090&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=824845&status=done&style=none&taskId=uad810358-cd94-4538-b11e-6ec32fab1dc&title=&width=726.6666666666666)

### 30.DOM树和渲染树有什么区别？

1. DOM树和html标签一一对应的，包括head和隐藏元素
2. 渲染树是不包含head和隐藏元素的
3. 形成的节点是现有dom树 才会有渲染树

### 31.精灵图和base64的区别是什么？

精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度
   base64：传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串
   base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载。

### 32.svg格式了解多少？

基于XML语法格式的图像格式，可缩放矢量图，其他图像是基于像素的，SVG是属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真
   1.SVG可直接插入页面中，成为DOM一部分，然后用JS或CSS进行操作

```
    <svg></svg>
```

2.SVG可作为文件被引入

```tsx
<img src="pic.svg">
```

3.SVG可以转为base64引入页面

### 33.了解过JWT吗？

```
Json Web Token,通过JSON形式作为web应用中的令牌，可以在各方之间安全的吧信息作为JSON对象传输。

信息的安全传输；授权，可以做单点登录

JWT的认证流程：

1. 前端吧账号密码发送给后端的接口
2. 后端核对账号密码成功后，把用户ID的其他信息作为JWT负载，把它和头部分别进行BASE64编码拼接后签名，形成一个JWT（token）.
3. 前端每次请求时，都会吧JWT放在HTTP请求头的Authorization字段内
4. 后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）
5. 验证通过后，后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果

优点：

简洁 体积小 包含性{包含了用户信息} json加密（安全）

因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何WEB形式都支持。
```

### 34.npm的底层环境是什么？

```
node package manager，nodejs的包管理和分发工具，已经成为分发node模块的标准，是JS的环境，

npm的组成：网站，注册表，命令行工具，
```

### 35.HTTP协议规定的协议头和请求头有什么？

```
请求头：

1. Accept:浏览器告诉服务所支持的数据类型
2. Host:浏览器告诉服务器我想访问服务器的那台主机
3. Referer:浏览器告诉服务器我是从哪里来的（防盗链）
4. User-Agent:浏览器类型，版本信息
5. Date:浏览器告诉服务器我是什么时候访问的
6. Connection:连接方式
7. Cookie：
8. X-request-With:请求方式

响应头：

1. Location:告诉浏览器你要去找谁
2. Server:告诉浏览器服务器的类型
3. Content-type:告诉浏览器返回的数据类型
4. Refresh:控制浏览器的定时刷新
```

### 36.说一下浏览器的缓存策略。

```
强缓存（本地缓存），协商缓存（弱缓存）

强缓存：不发起请求，直接使用缓存里的内容，浏览器吧JS，CSS,Image,等存到内存中，下次用户访问直接从内存中去取，提高性能。

触发条件：

**http 1.0 时间戳和响应标头来触发**

**http 1.1 cache-Control 这个来触发**

协商缓存：需要向后台发请求，通过一定的条件去判断来确定是否使用协商缓存，如果请求内容没有改变，则返回304，浏览器就用缓存里的内容。

触发条件：

**http 1.0 if-modified-since 响应头：last-modified**

**http 1.1 if-none-match 响应头：Etag**
```

### 37.说一下什么是“同源策略”？

| 协议     | 子域名 | 主域名    | 端口号 | 资源路径        |
| -------- | ------ | --------- | ------ | --------------- |
| https:// | www.   | baidu.com | :8080  | /index/index.js |

```javascript
同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击

主要指的是协议+域名+端口号三者一致，若其中一个不一样则 不是同源，会产生跨域

三个允许跨域加载资源标签是：img link script

跨域是可以发送请求，后端也会正常返回结果，只不过结果被浏览器拦截了

JSONP ：利用script标签的漏洞来

CORS ：需要后端支持 **Access-Control-Allow-Origin: * CORS注解**

websocket ：h5的持久化协议，自动支持浏览器和服务器的双向通信，在建立连接的之后，
websocketServer 和Clinet都会主动的向对方发送和接受数据，同时因为在建立连接的时候，
  已经借助了HTTP协议，此时已经可以支持双向通信了。

反向代理 ：类似中间件代理，属于消息数据的转发，
vue2 proxy proxyTable
nginx服务器，location proxy tag {目标DNS 服务}
nodejs 中间件 http-proxy-middleware
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');

const app = express();

// 设置代理，将请求代理到目标URL
const proxy = createProxyMiddleware('/api', {
    target: 'http://target-domain.com', // 目标服务器的URL
    changeOrigin: true, // 改变源到目标URL，允许跨域
    pathRewrite: {
        '^/api': '', // 重写路径
    },
});

app.use('/api', proxy);

// 可以添加其他中间件...

// 监听端口
app.listen(3000, () => {
    console.log('Server is running on http://localhost:3000');
});
```

### 38.防抖和节流是什么？

**防抖：**触发高频事件后，N秒内函数只会执行一次，如果N秒内再次触发，那么我的事件会重新执行，时间会重新计算
**节流**：我在N秒内只会执行一次，不管你触发多少次，我只执行第一次，待执行完成后，再次执行。
会降低函数的执行次数
都是应对页面中频繁触发事件的优化方案。

**防抖：避免事件的重复触发，**
使用场景：1. 频繁和服务器交互，2. 输入框的自动保存事件
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712715979450-cc67abd7-74a3-4692-b049-9ab4ff2c3280.png#averageHue=%23fdfcfc&clientId=u700e487e-5acc-4&from=paste&height=451&id=ud5d99920&originHeight=676&originWidth=958&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=279614&status=done&style=none&taskId=u23e9fbc7-892b-4441-8d86-c94751f8056&title=&width=638.6666666666666)
**节流：把频繁触发的事件减少，每隔一段时间执行**
使用场景：scroll事件
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712715992925-0fd14c58-8537-423d-a0dc-d4b47df34ca9.png#averageHue=%23f4f5f0&clientId=u700e487e-5acc-4&from=paste&height=455&id=uc5c2f87b&originHeight=682&originWidth=951&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=359203&status=done&style=none&taskId=uf5e9d152-f379-4887-8def-060bc348a9c&title=&width=634)
总结：
**防抖**触发高频事件后，N秒内函数只会执行一次，如果N秒内再次触发，那么我的时间会重新计算
**节流**：我在N秒内只会执行一次，不管你触发多少次，会降低函数的执行次数

### 39.解释一下什么是json？

1.  JSON是一种纯字符串形式的数据，它本身不提供任何方法，适合在网络中进行传输
2.  JSON数据存储在.json文件中，也可以把JSON数据以字符串的形式保存在数据库、Cookise中
3.  JS提供了JSON.parse() JSON.stringify()
       什么时候使用json：定义接口；序列化；生成token；配置文件package.json

### 40.当数据没有请求过来的时候，该怎么做？

可以在渲染数据的地方给一些默认的值
   if判断语句

### 41.有没有做过无感登录？

1.在相应其中拦截，判断token返回过期后，调用刷新token的接口
   2.后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口
   3.写定时器，定时刷新token接口
   流程：
       1.登录成功后保存token 和 refresh_token
       2.在响应拦截器中对401状态码引入刷新token的api方法调用
       3.替换保存本地新的token
       4.把错误对象里的token替换
       5.再次发送未完成的请求
       6.如果refresh_token过期了，判断是否过期，过期了就清楚所有token重新登录

### 42.大文件上传是怎么做的？

分片上传：
       1.把需要上传的文件按照一定的规则，分割成相同大小的数据块
       2.初始化一个分片上传任务，返回本次分片上传的唯一标识
       3.按照一定的规则把各个数据块上传
       4.发送完成后，服务端会判断数据上传的完整性，如果完整，那么就会把数据库合并成原始文件
   断点续传：
       服务端返回，从哪里开始  浏览器自己处理
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712716137804-2ab094a0-201d-41a5-90a2-112d25e4b083.png#averageHue=%23fdfdfc&clientId=u700e487e-5acc-4&from=paste&height=583&id=ub66f8feb&originHeight=874&originWidth=1080&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=524743&status=done&style=none&taskId=uf122f8fa-2783-4a63-a2f2-dfa65869898&title=&width=720)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712716149705-c78c7526-4422-4a85-9173-4298e4d3e671.png#averageHue=%23fdfcfc&clientId=u700e487e-5acc-4&from=paste&height=334&id=ubbf2219d&originHeight=501&originWidth=1066&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=254826&status=done&style=none&taskId=ubf1e9957-c5db-4c56-9c05-dfdaba7c797&title=&width=710.6666666666666)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712716167284-cd054f34-f4b4-4d74-9651-166efd8e8aad.png#averageHue=%23fdfcfb&clientId=u700e487e-5acc-4&from=paste&height=577&id=u7c044016&originHeight=865&originWidth=1066&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=509928&status=done&style=none&taskId=ua84d486b-9a26-41ee-a235-0ab16361e5e&title=&width=710.6666666666666)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712716181991-eb41dcca-904c-4101-aa33-7f64d3ed9e5c.png#averageHue=%23fdfdfc&clientId=u700e487e-5acc-4&from=paste&height=677&id=u226d6e60&originHeight=1015&originWidth=1033&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=399497&status=done&style=none&taskId=u26253eae-5c52-4457-9880-aa70dba6078&title=&width=688.6666666666666)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712716192705-5b478222-c4b0-4f80-8a66-f2468fd7d798.png#averageHue=%23fdfdfd&clientId=u700e487e-5acc-4&from=paste&height=190&id=uda10b5b8&originHeight=285&originWidth=855&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=108555&status=done&style=none&taskId=u1ef291b9-2f13-4b95-808a-69f008a2a49&title=&width=570)

## 三、HTML5CSS3

### 1.语义化的理解。

在写HTML页面结构时所用的标签有意义
       头部用head  主体用main  底部用foot...
       怎么判断页面是否语义化了？
           把CSS去掉，如果能够清晰的看出来页面结构，显示内容较为正常
       为什么要选择语义化？
           1.让HTML结构更加清晰明了
           2.方便团队协作，利于开发
           3.有利于爬虫和SEO
           4.能够让浏览器更好的去解析代码
           5.给用户带来良好的体验

### 2.H5C3有哪些新特性？

H5的新特性：
           1.语义化的标签
           2.新增音频视频
           3.画布canvas
           4.数据存储localstorage sessionstorage
           5.增加了表单控件 email url search...
           6.拖拽释放API
       CSS3的新特性：
           1.新增选择器：属性选择器、伪类选择器、伪元素选择器
           2.增加了媒体查询
           3.文字阴影
           4.边框
           5.盒子模型box-sizing
           6.渐变
           7.过度
           8.自定义动画
           9.背景的属性
           10.2D和3D

### 3.rem是如何做适配的？

rem是相对长度，相对于根元素（html）的font-size属性来计算大小，通常来做移动端的适配
       rem是根据根元素font-size计算值的倍数
       比如html上的font-size:16px，给div设置宽为1.5rem,1.2rem = 16px\*1.2 = 19.2px.

### 4.解决了哪些移动端的兼容问题？

1.当设置样式overflow:scroll/auto时，IOS上的滑动会卡顿
           -webkit-overflow-scrolling:touch;
       2.在安卓环境下placeholder文字设置行高时会偏上
           input有placeholder属性的时候不要设置行高
       3.移动端字体小于12px时异常显示
           应该先把在整体放大一倍，然后再用transform进行缩小
       4.ios下input按钮设置了disabled属性为true显示异常
           input[typy=button]{
               opcity:1
           }
       5.安卓手机下取消语音输入按钮
           input::-webkit-input-speech-button{
               display:none
           }
       6.IOS下取消input输入框在输入引文首字母默认大写

7.禁用IOS和安卓用户选中文字
           添加全局CSS样式：-webkit-user-select:none
       8.禁止IOS弹出各种窗口
           -webkit-touch-callout:none
       9.禁止IOS识别长串数字为电话
           添加meta属性

## 四、Vue

### 谈谈你对SPA单页面的理解

SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载
**优点：**

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
- 基于上面一点，SPA 相对对服务器压力小；
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理

**缺点：**

- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势

**单页应用与多页应用的区别**

|                 | 单页面应用（SPA）         | 多页面应用（MPA）                   |
| --------------- | ------------------------- | ----------------------------------- |
| 组成            | 一个主页面和多个页面片段  | 多个主页面                          |
| 刷新方式        | 局部刷新                  | 整页刷新                            |
| url模式         | 哈希模式                  | 历史模式                            |
| SEO搜索引擎优化 | 难实现，可使用SSR方式改善 | 容易实现                            |
| 数据传递        | 容易                      | 通过url、cookie、localStorage等传递 |
| 页面切换        | 速度快，用户体验良好      | 切换加载资源，速度慢，用户体验差    |
| 维护成本        | 相对容易                  | 相对复杂                            |

**实现一个SPA**

- 监听地址栏中hash变化驱动界面变化
- 用pushsate记录浏览器的历史，驱动界面发送变化

![](https://cdn.nlark.com/yuque/0/2024/png/29430977/1714026530874-6fdad366-d2cb-4eea-9f88-6a7252f75c3a.png#averageHue=%23f2f2f2&clientId=u36532424-ddd6-4&from=paste&id=ueb41f2ce&originHeight=500&originWidth=1376&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u0e1dafbf-c709-49a7-bf56-d283e780ee1&title=)

1. **hash 模式**：核心通过监听url中的hash来进行路由跳转

### vue声明函数为什么要用return{} 函数包裹

- 不使用return包裹的数据会在项目的全局可见，会造成变量污染；
- 使用return包裹后数据中变量只在当前组件中生效，不会影响其他组件。
- 当一个组件被定义， data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data函数，从而返回初始数据的一个全新副本数据对象。

类比与引用数据类型。**如果不用function return 每个组件的data都是内存的同一个地址**，那一个数据改变其他也改变了，这当然就不是我们想要的。用function return 其实就相当于申明了新的**变量**，相互独立，自然就不会有这样的问题；js在赋值object对象时，是直接一个相同的内存地址。所以为了每个组件的data独立，采用了这种方式。
如果不是组件的话，正常data的写法可以直接写一个对象，比如同一组件中的两个计算器都共用了data：{ num ： 0}，JS中直接共享对象会造成引用传递，也就是说按了加减按钮后所有num值都会跟着修改，所以这里用function来每次返回一个对象实例。

### 1.v-if和v-show的区别？

都可以控制元素的显示和隐藏
       1.v-show时控制元素的display值来让元素显示和隐藏；v-if显示隐藏时把DOM元素整个添加和删除
       2.v-if有一个局部编译/卸载的过程，切换这个过程中会适当的销毁和重建内部的事件监听和子组件；v-show只是简单的css切换
       3.v-if才是真正的条件渲染；v-show从false变成true的时候不会触发组件的声明周期，v-if会触发声明周期
       4.v-if的切换效率比较低  v-show的效率比较高

### 2.如何理解MVVM的？

是Model-View-ViewModel的缩写。前端开发的架构模式
       M：模型，对应的就是data的数据
       V：视图，用户界面，DOM
       VM：视图模型：Vue的实例对象，连接View和Model的桥梁
       核心是提供对View和ViewModel的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图，当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定
       ViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要认为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为她是由MVVM统一管理

### 3.v-for中的key值的作用是什么？

key属性是DOM元素的唯一标识
       作用：
           1.提高虚拟DOM的更新
           2.若不设置key，可能会触发一些bug
           3.为了触发过度效果4.继承v-for上的函数和方法，此处也可以成为事件委托的一种延续

### 4.说一下你对vue生命周期的理解。

组件从创建到销毁的过程就是它的生命周期
       创建
           beforeCreat
               在这个阶段属性和方法都不能使用
           created
               这里时实例创建完成之后，在这里完成了数据监测，可以使用数据，修改数据，不会触发updated，也不会更新视图
       挂载
           beforeMount
               完成了模板的编译，虚拟DOM也完成创建，即将渲染，修改数据，不会触发updated
           Mounted
               把编译好的模板挂载到页面，这里可以发送异步请求也可以访问DOM节点
       更新
           beforeUpdate
               组件数据更新之前使用，数据是新的，页面上的数据时旧的，组件即将更新，准备渲染，可以改数据
           updated
               render重新做了渲染，这时数据和页面都是新的，避免在此更新数据
       销毁
           beforeDestroy
               实例销毁前，在这里实例还可以用，可以清楚定时器等等
           destroyed
               组件已经被销毁了，全部都销毁
       使用了keep-alive时多出两个周期：
           activited
               组件激活时
           deactivited
               组件被销毁时
**vue3--------生命周期**

- Vue3中的生命周期
  setup() : 开始创建组件，在 beforeCreate 和 created 之前执行，创建的是 data 和 method
- onBeforeMount() : 组件挂载到节点上之前执行的函数；
- onMounted() : 组件挂载完成后执行的函数；
- onBeforeUpdate(): 组件更新之前执行的函数；
- onUpdated(): 组件更新完成之后执行的函数；
- onBeforeUnmount(): 组件卸载之前执行的函数；
- onUnmounted(): 组件卸载完成后执行的函数；
- onActivated(): 被包含在  中的组件，会多出两个生命周期钩子函数，被激活时执行；
- onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行；
- onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数。
- ![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712716268717-1883f9bd-c5c4-491a-9dad-fc0a5c4399c6.png#averageHue=%23f8f8f7&clientId=u700e487e-5acc-4&from=paste&height=524&id=u8fc47f81&originHeight=786&originWidth=1084&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=257440&status=done&style=none&taskId=ubb417af3-5ed1-4552-b3e8-52cb1537e9c&title=&width=722.6666666666666)

### 5.在created和mounted去请求数据，有什么区别？

created：在渲染前调用，通常先初始化属性，然后做渲染
       mounted：在模板渲染完成后，一般都是初始化页面后，在对元素节点进行操作
               在这里请求数据可能会出现闪屏的问题，created里不会
       一般用created比较多
       请求的数据对DOM有影响，那么使用created
       如果请求的数据对DOM无关，可以放在mounted

### 6.vue中的修饰符有哪些？

```
1.事件修饰符
.stop       阻止冒泡
.prevent    阻止默认行为
.capture    内部元素触发的事件先在次处理
.self       只有在event.target是当前元素时触发
.once       事件只会触发一次
.passive    立即触发默认行为
.native     把当前元素作为原生标签看待

2.按键修饰符
.keyup      键盘抬起
.keydown    键盘按下

3.系统修饰符
.ctrl
.alt
.meta

4.鼠标修饰符
.left       鼠标左键
.right      鼠标右键
.middle     鼠标中键

5.表单修饰符
.lazy       等输入完之后再显示
.trim       删除内容前后的空格
.number     输入是数字或转为数字

elementui是怎么做表单验证的？
- 1.在表单中加rules属性，然后再data里写校验规则
- 2.内部添加规则
- 3.自定义函数校验
```

### 7.elementui是怎么做表单验证的？

1. 在表单中加rules属性，然后再data里写校验规则
   ![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1713406304904-2092e6d2-1270-47ef-bbc7-588f9ad4c6d1.png#averageHue=%23fcfafa&clientId=uac43946f-9091-4&from=paste&height=187&id=u81b76d15&originHeight=280&originWidth=958&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=149057&status=done&style=none&taskId=u2ad0f8dc-cd41-4777-a09a-5b7ea5e8c16&title=&width=638.6666666666666)
          2. 内部添加规则
   ![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1713406356911-1f4538cf-ea77-4f06-8c98-0cd6b06a8cdd.png#averageHue=%23fdfcfc&clientId=uac43946f-9091-4&from=paste&height=358&id=uf865c7de&originHeight=537&originWidth=919&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=264310&status=done&style=none&taskId=ucfd20fdb-e364-45d2-820e-499780a01b0&title=&width=612.6666666666666)
          3. 自定义函数校验
   ![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1713406367539-af41176e-bad5-4c85-a996-e98dce4984d2.png#averageHue=%23fdfdfc&clientId=uac43946f-9091-4&from=paste&height=413&id=ua9010096&originHeight=619&originWidth=808&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=232948&status=done&style=none&taskId=u20ba6a72-2d7e-4438-a088-9139891f27d&title=&width=538.6666666666666)
   或者method里面去定义

### 8.vue如何进行组件通信？

1.父传子
           props
               父组件使用自定义属性，然后子组件使用props
           $ref
​                引用信息会注册在父组件的$refs对象上
       2.子传父
          $emit:子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数  	     this.$emit("getMsg",{a:123}) getMsg对应申明时候的事件名
       3.兄弟传
          eventBus : new一个新的vue实例，用on和emit来对数据进行传输
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712716333318-8693cb3c-f8c2-426e-b785-e587d8276559.png#averageHue=%23fcfcfc&clientId=u700e487e-5acc-4&from=paste&height=282&id=ubd4b0423&originHeight=423&originWidth=901&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=165278&status=done&style=none&taskId=ua2b174d1-6c13-46a5-bdaa-0c51998a1a8&title=&width=600.6666666666666)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712716346565-27fc99ba-06dd-412d-b7a3-2db5490701d6.png#averageHue=%23fdfdfd&clientId=u700e487e-5acc-4&from=paste&height=741&id=u309501d3&originHeight=1111&originWidth=898&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=362649&status=done&style=none&taskId=uefc5ac31-d2d5-45ec-bcbe-87c0abaf43a&title=&width=598.6666666666666)
       4.**vuex || pinia 传值**

### 9.keep-alive是什么？怎么使用？

Vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们
       作用：把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少加载时间和性能消耗，提高用户体验
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712716378502-ebb381c9-b31a-4116-a562-83a63ef36157.png#averageHue=%23fdfcfc&clientId=u700e487e-5acc-4&from=paste&height=670&id=u9d588c8e&originHeight=1005&originWidth=1072&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=410309&status=done&style=none&taskId=u0686d564-ee13-4663-8f8c-706495c8650&title=&width=714.6666666666666)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712716389402-3b5480a8-0899-4be0-9a5a-97ba15f56207.png#averageHue=%23fcfbfb&clientId=u700e487e-5acc-4&from=paste&height=612&id=ube91a108&originHeight=918&originWidth=1038&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=451447&status=done&style=none&taskId=u6ca2d82c-519b-4ea3-a33d-83f613f53f2&title=&width=692)

### 10.axios是怎么做封装的？

下载 创建实例 接着封装请求响应拦截器  抛出 最后封装接口
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712716412690-38c340a9-af29-40e3-93a6-5a1e06f8252b.png#averageHue=%23f1eee9&clientId=u700e487e-5acc-4&from=paste&height=817&id=uf22951c4&originHeight=1225&originWidth=802&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=521861&status=done&style=none&taskId=u53ebf1f2-95dc-40c2-8869-e818985a447&title=&width=534.6666666666666)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712716429896-f5beda4e-477f-47f4-92d4-b53b2db68497.png#averageHue=%23fdfcfc&clientId=u700e487e-5acc-4&from=paste&height=262&id=u5da06137&originHeight=393&originWidth=861&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=123563&status=done&style=none&taskId=u11aa05df-74d3-46c7-be3f-41e66455c22&title=&width=574)

### 11.vue路由时怎么传参的？

params传参

```tsx
this.$router.push({name:'index',params:{id:item.id}})`
this.$route.params.id
```

路由属性传参

```tsx
this.$router.push({ name: '/index/${item.id}' })
```

路由配置

```tsx
{
  path: '/index:id'
}
```

query传参（可以解决页面刷新参数丢失的问题）

```tsx
this.$router.push({
  name: 'index',
  query: { id: item.id },
})
```

### 12.vue路由的hash模式和history模式有什么区别？

1.hash的路由地址上有#号，history模式没有
       2.在做回车刷新的时候，hash模式会加载对应页面，history会报错404
       3.hash模式支持低版本浏览器，history不支持，因为是H5新增的API
       4.hash不会重新加载页面，单页面应用必备
       5.history有历史记录，H5新增了pushState和replaceState()去修改历史记录，并不会立刻发送请求
       6.history需要后台配置

### 12.1 $nextTick()原理

$nextTick() 是 Vue.js 框架中的一个方法，它主要用于 DOM 操作。当我们修改 Vue 组件中的数据时，Vue.js 会在下次事件循环前自动更新视图，并异步执行 $nextTick() 中的回调函数。这个过程可以确保 DOM 已经被更新，以及可以操作到最新的 DOM。
具体来说，当修改了 Vue 组件中的数据时，Vue.js 并不会立即进行视图更新。Vue.js 会将修改的数据记录下来，并在下一次事件循环时才更新视图。而 $nextTick() 方法则是用于等待这个事件循环结束后再执行回调函数。这样可以确保我们操作 DOM 的时候，DOM 已经被 Vue 更新过了。

- 先采用Promise
- Promise不支持，再采用MutationObserver
- MutationObserver不支持，再采用setImmediate
- 如果以上都不行则采用setTimeout
- 最后执行flushCallbacks，把callbacks里面的数据依次执行

### 13.路由拦截是怎么实现的？

路由拦截 axios拦截
       需要在路由配置中添加一个字段，它是用于判断路由是否需要拦截

```tsx
   {
            name:'index',
            path:'/index',
            component:Index,
            meta:{
                requirtAuth:true
            }
        }
        router.beforeEach((to,from,next) => {
            if(to.meta.requirtAuth){
                if( store.satte.token ){
                    next()
                }else{
                 }
		}
})
```

### 14.说一下vue的动态路由。

要在路由配置里设置meat属性，扩展权限相关的字段，在路由导航守卫里通过判断这个权限标识，实现路由的动态增加和跳转
根据用户登录的账号，返回用户角色
前端再根据角色，跟路由表的meta.role进行匹配
把匹配搭配的路由形成可访问的路由

### 15.如何解决刷新后二次加载路由？

```tsx
1.window.location.reload() 闪屏
2.matcher 匹配
const router = createRouter()
export function resetRouter(){
  const newRouter = creatRouter()
  router.matcher = newRouter.matcher
}
```

### 32 写过自定义指令吗？原理是什么

**回答范例**

1. Vue有一组默认指令，比如v-model或v-for，同时Vue也允许用户注册自定义指令来扩展Vue能力
2. 自定义指令主要完成一些可复用低层级DOM操作
3. 使用自定义指令分为定义、注册和使用三步：

- 定义自定义指令有两种方式：对象和函数形式，前者类似组件定义，有各种生命周期；后者只会在mounted和updated时执行
- 注册自定义指令类似组件，可以使用app.directive()全局注册，使用{directives:{xxx}}局部注册
- 使用时在注册名称前加上v-即可，比如v-focus

1. 我在项目中常用到一些自定义指令，例如：

- 复制粘贴 v-copy
- 长按 v-longpress
- 防抖 v-debounce
- 图片懒加载 v-lazy
- 按钮权限 v-premission
- 页面水印 v-waterMarker
- 拖拽指令 v-draggable

1. vue3中指令定义发生了比较大的变化，主要是钩子的名称保持和组件一致，这样开发人员容易记忆，不易犯错。另外在v3.2之后，可以在setup中以一个小写v开头方便的定义自定义指令，更简单了

#### 基本使用

当Vue中的核心内置指令不能够满足我们的需求时，我们可以定制自定义的指令用来满足开发的需求
我们看到的v-开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能，对普通 DOM元素进行底层操作，这时候就会用到自定义指令。除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令

```
// 指令使用的几种方式：
//会实例化一个指令，但这个指令没有参数
`v-xxx`

// -- 将值传到指令中
`v-xxx="value"`

// -- 将字符串传入到指令中，如`v-html="'<p>内容</p>'"`
`v-xxx="'string'"`

// -- 传参数（`arg`），如`v-bind:class="className"`
`v-xxx:arg="value"`

// -- 使用修饰符（`modifier`）
`v-xxx:arg.modifier="value"`

        @程序员poetry: 代码已经复制到剪贴板
```

注册一个自定义指令有全局注册与局部注册

```
// 全局注册注册主要是用过Vue.directive方法进行注册
// Vue.directive第一个参数是指令的名字（不需要写上v-前缀），第二个参数可以是对象数据，也可以是一个指令函数
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()  // 页面加载完成之后自动让输入框获取到焦点的小功能
  }
})

// 局部注册通过在组件options选项中设置directive属性
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能
    }
  }
}

// 然后你可以在模板中任何元素上使用新的 v-focus property，如下：

<input v-focus />

        @程序员poetry: 代码已经复制到剪贴板
```

**钩子函数**

1. bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
2. inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
3. update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。
4. componentUpdated：被绑定元素所在模板完成一次更新周期时调用。
5. unbind：只调用一次，指令与元素解绑时调用。

所有的钩子函数的参数都有以下：

- el：指令所绑定的元素，可以用来直接操作 DOM
- binding：一个对象，包含以下 property：
  - name：指令名，不包括 v- 前缀。
  - value：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。
  - oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
  - expression：字符串形式的指令表达式。例如 v-my-directive="1 + 1" 中，表达式为 "1 + 1"。
  - arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。
  - modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }
  - vnode：Vue 编译生成的虚拟节点
  - oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用

除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行

```
<div v-demo="{ color: 'white', text: 'hello!' }"></div>
<script>
    Vue.directive('demo', function (el, binding) {
    console.log(binding.value.color) // "white"
    console.log(binding.value.text)  // "hello!"
    })
</script>

        @程序员poetry: 代码已经复制到剪贴板
```

**应用场景**
使用自定义组件组件可以满足我们日常一些场景，这里给出几个自定义组件的案例：

1. 防抖

```
// 1.设置v-throttle自定义指令
Vue.directive('throttle', {
  bind: (el, binding) => {
    let throttleTime = binding.value; // 防抖时间
    if (!throttleTime) { // 用户若不设置防抖时间，则默认2s
      throttleTime = 2000;
    }
    let cbFun;
    el.addEventListener('click', event => {
      if (!cbFun) { // 第一次执行
        cbFun = setTimeout(() => {
          cbFun = null;
        }, throttleTime);
      } else {
        event && event.stopImmediatePropagation();
      }
    }, true);
  },
});
// 2.为button标签设置v-throttle自定义指令
<button @click="sayHello" v-throttle>提交</button>

        @程序员poetry: 代码已经复制到剪贴板
```

1. 图片懒加载

设置一个v-lazy自定义组件完成图片懒加载

```
const LazyLoad = {
    // install方法
    install(Vue,options){
       // 代替图片的loading图
        let defaultSrc = options.default;
        Vue.directive('lazy',{
            bind(el,binding){
                LazyLoad.init(el,binding.value,defaultSrc);
            },
            inserted(el){
                // 兼容处理
                if('InterpObserver' in window){
                    LazyLoad.observe(el);
                }else{
                    LazyLoad.listenerScroll(el);
                }

            },
        })
    },
    // 初始化
    init(el,val,def){
        // src 储存真实src
        el.setAttribute('src',val);
        // 设置src为loading图
        el.setAttribute('src',def);
    },
    // 利用InterpObserver监听el
    observe(el){
        let io = new InterpObserver(entries => {
            let realSrc = el.dataset.src;
            if(entries[0].isIntersecting){
                if(realSrc){
                    el.src = realSrc;
                    el.removeAttribute('src');
                }
            }
        });
        io.observe(el);
    },
    // 监听scroll事件
    listenerScroll(el){
        let handler = LazyLoad.throttle(LazyLoad.load,300);
        LazyLoad.load(el);
        window.addEventListener('scroll',() => {
            handler(el);
        });
    },
    // 加载真实图片
    load(el){
        let windowHeight = document.documentElement.clientHeight
        let elTop = el.getBoundingClientRect().top;
        let elBtm = el.getBoundingClientRect().bottom;
        let realSrc = el.dataset.src;
        if(elTop - windowHeight<0&&elBtm > 0){
            if(realSrc){
                el.src = realSrc;
                el.removeAttribute('src');
            }
        }
    },
    // 节流
    throttle(fn,delay){
        let timer;
        let prevTime;
        return function(...args){
            let currTime = Date.now();
            let context = this;
            if(!prevTime) prevTime = currTime;
            clearTimeout(timer);

            if(currTime - prevTime > delay){
                prevTime = currTime;
                fn.apply(context,args);
                clearTimeout(timer);
                return;
            }

            timer = setTimeout(function(){
                prevTime = Date.now();
                timer = null;
                fn.apply(context,args);
            },delay);
        }
    }

}
export default LazyLoad;

        @程序员poetry: 代码已经复制到剪贴板
```

1. 一键 Copy的功能

```
import { Message } from 'ant-design-vue';

const vCopy = { //
  /*
    bind 钩子函数，第一次绑定时调用，可以在这里做初始化设置
    el: 作用的 dom 对象
    value: 传给指令的值，也就是我们要 copy 的值
  */
  bind(el, { value }) {
    el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到
    el.handler = () => {
      if (!el.$value) {
      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意
        Message.warning('无复制内容');
        return;
      }
      // 动态创建 textarea 标签
      const textarea = document.createElement('textarea');
      // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域
      textarea.readOnly = 'readonly';
      textarea.style.position = 'absolute';
      textarea.style.left = '-9999px';
      // 将要 copy 的值赋给 textarea 标签的 value 属性
      textarea.value = el.$value;
      // 将 textarea 插入到 body 中
      document.body.appendChild(textarea);
      // 选中值并复制
      textarea.select();
      // textarea.setSelectionRange(0, textarea.value.length);
      const result = document.execCommand('Copy');
      if (result) {
        Message.success('复制成功');
      }
      document.body.removeChild(textarea);
    };
    // 绑定点击事件，就是所谓的一键 copy 啦
    el.addEventListener('click', el.handler);
  },
  // 当传进来的值更新的时候触发
  componentUpdated(el, { value }) {
    el.$value = value;
  },
  // 指令与元素解绑的时候，移除事件绑定
  unbind(el) {
    el.removeEventListener('click', el.handler);
  },
};

export default vCopy;

        @程序员poetry: 代码已经复制到剪贴板
```

1. 拖拽

```
<div ref="a" id="bg" v-drag></div>

  directives: {
    drag: {
      bind() {},
      inserted(el) {
        el.onmousedown = (e) => {
          let x = e.clientX - el.offsetLeft;
          let y = e.clientY - el.offsetTop;
          document.onmousemove = (e) => {
            let xx = e.clientX - x + "px";
            let yy = e.clientY - y + "px";
            el.style.left = xx;
            el.style.top = yy;
          };
          el.onmouseup = (e) => {
            document.onmousemove = null;
          };
        };
      },
    },
  }

        @程序员poetry: 代码已经复制到剪贴板
```

#### 原理

- 指令本质上是装饰器，是 vue对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。
- 自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind

**原理**

1. 在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性
2. 通过 genDirectives 生成指令代码
3. 在 patch 前将指令的钩子提取到 cbs 中,在 patch 过程中调用对应的钩子
4. 当执行指令对应钩子函数时，调用对应指令定义的方法

### vue3.2 自定义全局指令、局部指令

```
// 在src目录下新建一个directive文件，在此文件夹下新建一个index.js文件夹，接着输入如下内容
const directives =  (app) => {
  //这里是给元素取得名字，虽然是focus，但是实际引用的时候必须以v开头
  app.directive('focus',{
    //这里的el就是获取的元素
    mounted(el) {
      el.focus()
     }
  })
}

//默认导出 directives
export default directives

        @程序员poetry: 代码已经复制到剪贴板
```

```
// 在全局注册directive
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
import directives from './directives'

const app = createApp(App)
directives(app)

app.use(store).use(router).mount('#app')

        @程序员poetry: 代码已经复制到剪贴板
```

```
<!-- 在你需要的页面进行自定义指令的使用 -->
<template>
  <div class="container">
    <div class="content">
      <input type="text"  v-focus>
      内容
    </div>
  </div>
</template>

<script setup>
import { reactive, ref } from 'vue'
// const vMove:Directive = () =>{

// }
</script>

        @程序员poetry: 代码已经复制到剪贴板
```

在vue3.2 setup语法糖模式下，自定义指令变得及其简单

```
<input type="text" v-model="value" v-focus>

<script setup>
//直接写，但是必须是v开头
const vFocus = {
  mounted(el) {
    // 获取input，并调用其focus()方法
    el.focus()
  }
}
</script>

        @程序员poetry: 代码已经复制到剪贴板
```

```
<!-- demo 进去页面自动获取焦点，然后让盒子的颜色根据你input框输入的内容变色，并且作防抖处理 -->

<template>
  <div class="container">
    <div class="content" v-move="{ background: value }">
      内容
      <input type="text" v-model="value" v-focus @keyup="see">
    </div>
  </div>
</template>

<script setup>
import { reactive, ref } from 'vue'
const value = ref('')

const vFocus = {
  mounted(el) {
    // 获取input，并调用其focus()方法
    el.focus()
  }
}

let timer = null

const vMove = (el, binding) => {
  if (timer !== null) {
    clearTimeout(timer)
  }
  timer = setTimeout(() => {
    el.style.background = binding.value.background
    console.log(el);
  }, 1000);
}

</script>

<style lang="scss" scoped>
.container {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;

  .content {
    border-top: 5px solid black;
    width: 200px;
    height: 200px;
    cursor: pointer;
    border-left: 1px solid #ccc;
    border-right: 1px solid #ccc;
    border-bottom: 1px solid #ccc;
  }
}
</style>

        @程序员poetry: 代码已经复制到剪贴板
```

### 16.vuex刷新数据会丢失吗？怎么解决？

```tsx
vuex肯定会重新获取数据，页面也会丢失数据
1.把数据直接保存在浏览器缓存里（cookie  localstorage  sessionstorage）
2.页面刷新的时候，再次请求数据，达到可以动态更新的方法
监听浏览器的刷新书简，在刷新前把数据保存到sessionstorage里，刷新后请求数据，请求到了用vuex，如果没有那就用sessionstorage里的数据
```

### 17.computed和watch的区别？

```tsx
1.computed是计算属性，watch是监听，监听的是data中数据的变化
2.computed是支持缓存，依赖的属性值发生变化，计算属性才会重新计算，否则用缓存；watch不支持缓存
3.computed不支持异步，watch是可以异步操作
4.computed是第一次加载就监听，watch是不监听 watch第一次加载需要使用immediate:true
5.computed函数中必须有return  watch不用
```

### 18.vuex在什么场景会去使用？属性有哪些？

```tsx
state       存储变量
getters     state的计算属性
mutations   提交更新数据的方法
actions     和mutations差不多，他是提交mutations来修改数据，可以包括异步操作
modules     模块化vuex
使用场景：
用户的个人信息、购物车模块、订单模块
```

### 说说你对 proxy 的理解，Proxy 相比于 defineProperty 的优势

**Object.defineProperty() 的问题主要有三个：**

- **不能监听数组的变化**：无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应
- **必须遍历对象的每个属性**：只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象
- **必须深层遍历嵌套的对象**

**Proxy的优势如下:**

- 针对对象：**针对整个对象，而不是对象的某个属性**，所以也就不需要对 keys 进行遍历
- 支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的
- Proxy的第二个参数可以有 13 种拦截方：不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的
- Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改
- Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利

[proxy详细使用点击查看(opens new window)](https://es6.ruanyifeng.com/#docs/proxy)
**Object.defineProperty的优势如下:**
兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平
**defineProperty的属性值有哪些**

```
Object.defineProperty(obj, prop, descriptor)

// obj 要定义属性的对象
// prop 要定义或修改的属性的名称
// descriptor 要定义或修改的属性描述符

Object.defineProperty(obj,"name",{
  value:"poetry", // 初始值
  writable:true, // 该属性是否可写入
  enumerable:true, // 该属性是否可被遍历得到（for...in， Object.keys等）
  configurable:true, // 定该属性是否可被删除，且除writable外的其他描述符是否可被修改
  get: function() {},
  set: function(newVal) {}
})

        @程序员poetry: 代码已经复制到剪贴板
```

**相关代码如下**

```
import { mutableHandlers } from "./baseHandlers"; // 代理相关逻辑
import { isObject } from "./util"; // 工具方法

export function reactive(target) {
  // 根据不同参数创建不同响应式对象
  return createReactiveObject(target, mutableHandlers);
}
function createReactiveObject(target, baseHandler) {
  if (!isObject(target)) {
    return target;
  }
  const observed = new Proxy(target, baseHandler);
  return observed;
}

const get = createGetter();
const set = createSetter();

function createGetter() {
  return function get(target, key, receiver) {
    // 对获取的值进行放射
    const res = Reflect.get(target, key, receiver);
    console.log("属性获取", key);
    if (isObject(res)) {
      // 如果获取的值是对象类型，则返回当前对象的代理对象
      return reactive(res);
    }
    return res;
  };
}
function createSetter() {
  return function set(target, key, value, receiver) {
    const oldValue = target[key];
    const hadKey = hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (!hadKey) {
      console.log("属性新增", key, value);
    } else if (hasChanged(value, oldValue)) {
      console.log("属性值被修改", key, value);
    }
    return result;
  };
}
export const mutableHandlers = {
  get, // 当获取属性时调用此方法
  set, // 当修改属性时调用此方法
};

        @程序员poetry: 代码已经复制到剪贴板
```

Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？
判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。
**监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？**
我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger

### nextTick在哪里使用？原理是？

- nextTick 中的回调是在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM
- 在修改数据之后立即使用这个方法，获取更新后的 DOM
- 主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法

nextTick 方法主要是使用了宏任务和微任务,定义了一个异步方法.多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。所以这个 nextTick 方法就是异步方法
**根据执行环境分别尝试采用**

- 先采用Promise
- Promise不支持，再采用MutationObserver
- MutationObserver不支持，再采用setImmediate
- 如果以上都不行则采用setTimeout
- 最后执行flushCallbacks，把callbacks里面的数据依次执行

![](https://cdn.nlark.com/yuque/0/2024/png/29430977/1713410152197-cf730853-6701-40c4-a677-1703810b6865.png#averageHue=%23f5f1f1&clientId=uac43946f-9091-4&from=paste&id=u76a0fad1&originHeight=676&originWidth=1354&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u402c986e-36a1-4eaf-a942-393dc155a93&title=)
**回答范例**

1. nextTick 中的回调是在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM
2. Vue有个异步更新策略，意思是如果数据变化，Vue不会立刻更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新。这一策略导致我们对数据的修改不会立刻体现在DOM上，此时如果想要获取更新后的DOM状态，就需要使用nextTick
3. 开发时，有两个场景我们会用到nextTick

- created中想要获取DOM时
- 响应式数据变化后获取DOM更新后的状态，比如希望获取列表更新后的高度

1. nextTick签名如下：function nextTick(callback?: () => void): Promise<void>

所以我们只需要在传入的回调函数中访问最新DOM状态即可，或者我们可以await nextTick()方法返回的Promise之后做这件事

1. 在Vue内部，nextTick之所以能够让我们看到DOM更新后的结果，是因为我们传入的callback会被添加到队列刷新函数(flushSchedulerQueue)的后面，这样等队列内部的更新函数都执行完毕，所有DOM操作也就结束了，callback自然能够获取到最新的DOM值

### 313 说说Vue2.0和Vue3.0有什么区别

- 重构响应式系统，使用Proxy替换Object.defineProperty，使用Proxy优势：
  - 可直接监听数组类型的数据变化
  - 监听的目标为对象本身，不需要像Object.defineProperty一样递归遍历每个属性，如有一定的性能提升
  - 可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行
  - 直接实现对象属性的新增/删除
- 新增Composition API，替代了 options API，更好的逻辑复用和代码组织
- 重构 Virtual DOM
  - 模板编译时的优化，将一些静态节点编译成常量
  - slot优化，将slot编译为lazy 累Z函数，将slot的渲染的决定权交给子组件
  - 模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）
- 代码结构调整，更便于Tree shaking，使得体积更小
- 使用Typescript替换Flow

---

- proxy响应式：深度监听，性能更好（获取到哪一层才触发响应式get，不是一次性递归）
- PatchFlag 动态节点做标志
- HoistStatic 将静态节点的定义，提升到父作用域，缓存起来。多个相邻的静态节点，会被合并起来
- CacheHandler 事件缓存
- SSR优化: 静态节点不走vdom逻辑，直接输出字符串，动态节点才走
- Tree-shaking 根据模板的内容动态import不同的内容，不需要就不import
- **Fragment 不需要最外层div 了、Teleport 弹出层写在外层 to="#指定的标签节点"、Suspense 骨架屏的初始化加载loading**

### Vue组件data为什么必须是个函数？

- **根实例对象data可以是对象也可以是函数**（根实例是单例），不会产生数据污染情况
- **组件实例对象data必须为函数** .vue文件在使用的时候实际上会转换成一个class，一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件在不同的实例之间data不冲突，data必须是一个函数，

### Vue2.x 响应式数据原理

**整体思路是数据劫持+观察者模式**
对象内部通过 defineReactive 方法，使用 Object.defineProperty 来劫持各个属性的 setter、getter（只会劫持已经存在的属性），数组则是通过重写数组7个方法（push,shift,pop,splice,unshift,sort,reverse）来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)

### Vue3.x 响应式数据原理

Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。
Vue 3 实现了对数组的响应式，主要是通过重写以下数组的13种操作方法：

1. push() pop() shift() unshift() splice() sort() reverse()

filter() - 非原地操作，返回新数组 map() - 非原地操作，返回新数组
slice() - 非原地操作，返回新数组 flat() - 非原地操作，返回新数组，ES2019
flatMap() - 非原地操作，返回新数组，ES2019 concat() - 非原地操作，返回新数组
slice 和substring 区别是是否改变原数组 以及substring 不支持负数 反向取值

### vue2 的单向数据流 双向数据流

v-bind:msg ="msg" 单向
v-model:msg="msg" 双向

### v-if 和v-for的 优先级

vue2 是v-for优先于v-if
vue3 是v-if 优先于 v-for

### 怎样理解 Vue 的单向数据流

数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会**防止从子组件意外改变父级组件的状态**，从而导致你的应用的数据流向难以理解
**注意**：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告
如果实在要改变父组件的 prop 值，可以在 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改
**有两种常见的试图改变一个 prop 的情形 :**

1. 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop用作其初始值

```
props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}

```

1. 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性

```
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```

### 19.vue的双向数据绑定原理是什么？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1714101018242-de448aaf-fbf6-40e7-b502-c44d2d9b2d19.png#averageHue=%23fdf9f3&clientId=uf44564a8-3a81-4&from=paste&height=633&id=u1beb6ce1&originHeight=949&originWidth=1707&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=229440&status=done&style=none&taskId=u0413aa75-fbb5-445d-b635-6b3d87b246a&title=&width=1138)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1714101084623-7e37bf50-e2a3-490e-8d42-4eaa8606eda1.png#averageHue=%23f0eee1&clientId=uf44564a8-3a81-4&from=paste&height=783&id=uf83d3237&originHeight=1174&originWidth=1462&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=845968&status=done&style=none&taskId=ud6b49996-09e8-4181-9dcb-f01bfe65763&title=&width=974.6666666666666)

```tsx
通过数据劫持和发布订阅者模式来实现，同时利用Object.defineProperty()劫持各个属性的setter和getter，
在数据发生改变的时候发布消息给属性订阅者（Dep），触发对应的监听回调渲染视图，也就是说数据和视图时同步的，
  数据发生改变，视图跟着发生改变，视图改变，数据也会发生改变。
第一步：需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter
第二步：compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应
  的节点绑定上更新函数update()，添加订阅者Watcher()，如果数据变化，通知属性订阅器Dep，Dep.notice()
    收到通知，更新视图
第三步：Watcher订阅者是Observer和Compile之间的通信桥梁，作用：
1.在自身实例化的时候往订阅器内添加自己
2.自身要有一个update()方法
3.等待属性变动时，调用自身的update方法，触发compile解析器的回调
第四步：MVVM作为数据绑定的入口，整合了observer、compile和watcher三者，
  通过observer来监听自己的数据变化，通过compile解析模板指令，最后利用watcher
    把observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果
```

### 20.了解diff算法和虚拟DOM吗？

```tsx
虚拟DOM，描述元素和元素之间的关系，创建一个JS对象
如果组件内有响应的数据，数据发生改变的时候，render函数会生成一个新的虚拟DOM，这个新的虚拟DOM会和旧的虚拟DOM进行比对，找到需要修改的虚拟DOM内容，然后去对应的真实DOM中修改
diff算法就是虚拟DOM的比对时用的，返回一个patch对象，这个对象的作用就是存储两个节点不同的地方，最后用patch里记录的信息进行更新真实DOM
步骤：
1.JS对象表示真实的DOM结构，要生成一个虚拟DOM，再用虚拟DOM构建一个真实DOM树，渲染到页面
2.状态改变生成新的虚拟DOM，跟就得虚拟DOM进行比对，这个比对的过程就是DIFF算法，利用patch记录差异
3.把记录的差异用在第一个虚拟DOM生成的真实DOM上，视图就更新了。
```

### 21.vue和jquery的区别是什么？

```tsx
1.原理不同
vue就是数据绑定；jq是先获取dom再处理
2.着重点不同
vue是数据驱动，jq是着重于页面
3.操作不同
4.未来发展不同
```

### 22.vuex的响应式处理。

```tsx
vuex是vue的状态管理工具
vue中可以直接触发methods中的方法，vuex是不可以的。未来处理异步，当触发事件的时候，会通过dispatch来访问actions中的方法，actions中的commit会触发mutations中的方法从而修改state里的值，通过getter把数据更新到视图
Vue.use(vuex)，调用install方法，通过applyMixin(vue)在任意组件内执行this.$store就可以访问到store对象。
vuex的state是响应式的，借助的就是vue的data，把state存到vue实例组件的data中
```

### 23.vue中遍历全局的方法有哪些？

```tsx
1.普通遍历，对象.forEach()
arr.forEach(function(item,index,arr){
  console.log(item,index)
})
2.对元素统一操作  对象.map()
var newarr = arr.map(function(item){
  return item+1
})
3.查找符合条件的元素 对象.filter()
arr.filter(function(item){
  if(item > 2){
    return false
  }else{
    return true
  }
})
4.查询符合条件的元素，返回索引 对象.findindex()
arr.finindex(function(item){
  if(item>1){
    return true
  }else{
    return false
  }
})
对象.evening()  遇到不符合的对象会停止
对象.some()  找到符合条件的元素就停止
```

### 24.如何搭建脚手架？

```tsx
下载：node  cnpm  webpack vue-cli
创建项目：
1.找到对应的文件，然后利用node指令创建（cmd）
2.vue init webpack xxxx
3.回车项目描述
4.作者回车
5.选择vue build
6.回车
7.输入n
8.不按照yarn
9.输入npm run dev
```

### 25.如何封装一个组件？ 写一个一个组件？

```tsx
1.使用Vue.extend()创建一个组件
2.使用Vue.components()方法注册组件
3.如果子组件需要数据，可以在props中接收定义
4.子组件修改好数据，要把数据传递给父组件，可以用emit()方法
原则：
把功能拆开
尽量让组件原子化，一个组件做一件事情
容器组件管数据，展示组件管视图
```

### 26.封装一个可复用的组件，需要满足什么条件？

```tsx
1.低耦合，组件之间的依赖越小越好
2.最好从父级传入信息，不要在公共组件中请求数据
3.传入的数据要进行校验
4.处理事件的方法写在父组件中
```

### 27.vue的过滤器怎么使用？

```tsx
vue的特性，用来对文本进行格式化处理
使用它的两个地方，一个是插值表达式，一个是v-bind
分类：
1.全局过滤器
Vue.filter('add',function(v){
  return v < 10 ? '0' + v : v
})
  <div>{{33 | add}}</div>
    2.本地过滤器
    和methods同级
    filter:{
      add:function(v){
        return v < 10 ? '0' + v : v
          }
          }
```

### 28.vue中如何做强制刷新？

```tsx
1.localtion.reload()
2.this.$router.go(0)
3.provide和inject
```

### 29.vue3和vue2有哪些区别？

```tsx
1.双向数据绑定的原理不同
2.是否支持碎片
3.API不同
4.定义数据变量方法不同
5.生命周期的不同
6.传值不同
7.指令和插槽不同
8.main.js不同
```

### 如何理解Composition API和Options API

**composition API对比Option API**

- Composition API带来了什么
  - 更好的代码组织
  - 更好的逻辑复用
  - 更好的类型推导
- Composition API和Options API如何选择
  - 不建议共用，会引起混乱
  - 小型项目、业务逻辑简单，用Option API成本更小一些
  - 中大型项目、逻辑复杂，用Composition API

### Vue3为何比Vue2快

- proxy响应式：深度监听，性能更好（获取到哪一层才触发响应式get，不是一次性递归）
- PatchFlag 动态节点做标志
- HoistStatic 将静态节点的定义，提升到父作用域，缓存起来。多个相邻的静态节点，会被合并起来
- CacheHandler 事件缓存
- SSR优化: 静态节点不走vdom逻辑，直接输出字符串，动态节点才走
- Tree-shaking 根据模板的内容动态import不同的内容，不需要就不import

### 30.vue的性能优化怎么做？

```tsx
1.编码优化
不要把所有数据都放在data中
v-for时给每个元素绑定事件用事件代理
keep-alive缓存组件
尽可能拆分组件，提高复用性、维护性
key值要保证唯一
合理使用路由懒加载，异步组件
数据持久化存储的使用尽量用防抖、节流优化
2.加载优化
按需加载
内容懒加载
图片懒加载
3.用户体验
骨架屏
4.SEO优化
预渲染
服务端渲染ssr
5.打包优化
CDN形式加载第三方模块
多线程打包
抽离公共文件
6.缓存和压缩
客户端缓存、服务端缓存
服务端Gzip压缩
```

### 31.首屏优化该如何去做？

```tsx
1.使用路由懒加载
2.非首屏组件使用异步组件
3.首屏不中要的组件延迟加载
4.静态资源放在CDN上
5.减少首屏上JS、CSS等资源文件的大小
6.使用服务端渲染
7.简历减少DOM的数量和层级
8.使用精灵图请求
9.做一些loading
10.开启Gzip压缩
11.图片懒加载
```

### 32.vue3的性能为什么比vue2好？

```tsx
1.diff算法的优化
2.静态提升
3.事件侦听缓存
```

### 33.vue3为什么使用proxy？

```tsx
1.proxy可以代理整个对象，defineproperty只代理对象上的某个属性
2.proxy对代理对象的监听更加丰富
3.proxy代理对象会生成新的对象，不会修改被代理对象本身
4.proxy补兼容ie浏览器
```

### 34.说一下你对组件的理解。

```tsx
可以重复使用的vue实例，独一无二的组件名称
可以抽离单独的公共模块
提高代码的复用率
```

### 35.你是如何规划项目文件的？

```tsx
public
图标、index.html、img
src
api
assets
components
按分类再次划分子目录
plugins
router
static
styles
utils
views
App.vue
main.js
package.json
vue.config.js
```

### 36.是否使用过nuxt.js？

```tsx
是基于vue的应用框架，关注的是渲染，可以开发服务端渲染应用的配置
SSR：服务端渲染
好处：
SSR生成的是有内容的HTML页面，有利于搜索引擎的搜索
优化了首屏加载时间
SEO：优化搜索引擎
SPA的应用不利于搜索引擎SEO的操作
```

### 37.SEO如何优化？

```tsx
1.SSR
2.预渲染 prerender-spa-plugin
```

## 五、Echarts

### 1.echarts有用过吗？常用的组件有哪些？

title标题组件 show  text  link
       toolbox工具栏 导出图片 数据视图 切换 缩放 show orient feature
       tooltip tigger 触发类型
       markPoint标注点
       markLine图标的标线

## 六、Uni-APP

### 1.uni-app有没有做过分包？

优化小程序的下载和启动速度
       小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示

## 七、Weabpack

### 1.webpack打包和不打包的区别？

1.运行效率
       2.对基础的支持不够

### 2.webpack是怎么打包的，babel是做什么的？

webpack会把js css image看作一个模块，用import/require引入
       找到入口文件，通过入口文件找到关联的依赖文件，把他们打包到一起
       把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件
       如果一个被多个文件引用，打包时只会生成一个文件
       如果引用的文件没有调用，不会打包，如果引入的变量和方法没有调用也不会打包
       对于多个入口文件，加入引入了相同的代码，可以用插件把他抽离到公共文件中

## 八、Git

### 1.git如何合并、拉取代码？

拉取代码 git pull '仓库地址'
       查看状态 git sattus
       提交到本地缓存区  git add .
       提交本地仓库 git commit -m '修改描述'
       提交到远程仓库 git push '仓库地址' master
       创建分支 git branch -b xxx
       合并分支 git merge '合并分支的名字'

### 2.git如何解决冲突问题？

1.两个分支中修改了同一个文件
       2.两个分支中修改了同一个文件的名字
       1.解决：当前分支上，直接修改代码  add  commit
       2.解决：在本地当前分支上，修改冲突代码 add commit push

## 更新知识

一文给你说透前端工程化。
![](https://cdn.nlark.com/yuque/0/2024/webp/29430977/1713759880722-653d2d18-1d32-4f24-a88e-ab8be137773d.webp#averageHue=%23fbf8f6&clientId=u42c36c5f-8ae5-4&from=paste&id=udc31cbbe&originHeight=725&originWidth=1440&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7e8d55e1-67e5-41df-be55-57a561578c3&title=)

### 平时如何管理你的项目

项目管理在前端开发中非常重要，以下是一些常见的项目管理实践：

1. **确定项目全局约定**：团队需要确定全局样式、编码规范、命名约定等，以保证代码的一致性和可维护性。
2. **统一编码风格**：团队成员需要遵循统一的编码风格，例如使用继承式的写法、单样式一行等，以提高代码的可读性和可理解性。
3. **标注样式和模块**：及时在代码中标注关键样式的编写人以及调用的地方，同时对页面进行标注，方便团队成员的理解和协作。
4. **文件组织结构**：将CSS和HTML文件分别放在不同的文件夹中，并统一命名规则，例如使用style.css作为CSS文件的命名。
5. **JS文件管理**：将JS文件放在独立的文件夹中，并根据功能进行命名，使用英文翻译来描述其功能。
6. **图片整合与优化**：采用整合的方式使用图片，并使用适当的格式和优化策略，以减少文件大小和提升加载速度。
7. **规范代码注释**：对代码进行详细的注释，包括HTML、JS、CSS等，以提高代码的可读性和可维护性。
8. **严格要求静态资源存放路径**：规定静态资源的存放路径，遵循统一的文件夹结构，方便团队成员查找和管理资源文件。
9. **Git提交说明**：在每次提交代码到版本控制系统时，要求团队成员填写清晰的提交说明，描述提交的内容和目的。

这些项目管理实践可以提高团队的协作效率、代码质量和项目可维护性，确保项目的顺利进行和成功交付。

### [#](https://interview.poetries.top/docs/base.html#_6-%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85)6 组件封装 如何写一个组件

1. **分析布局**：首先需要对布局进行分析，确定组件的结构和样式。了解组件在不同场景下的表现形式和行为。
2. **初步开发**：根据布局的分析，开始进行组件的初步开发，包括HTML结构、CSS样式和基本的交互行为。
3. **化繁为简**：在初步开发的基础上，对组件进行优化和简化。去除冗余的代码，提取通用的样式和功能，确保组件的精简和高效。
4. **组件抽象**：在封装组件时，需要将组件的功能进行抽象，使其具有单一的职责和可复用性。将组件的各个部分分离，并提供适当的接口和配置项，使组件的使用更加灵活。

**常用的操作包括：**

- 使用合适的命名规范，保证组件的易读性和可维护性。
- 提供必要的文档和示例，方便其他开发人员使用和理解组件。
- 尽量降低组件与外部环境的耦合度，使其在不同的项目中都能够灵活使用。
- 考虑组件的可扩展性，使其能够适应未来的需求变化。
- 在开发过程中进行测试，确保组件的功能和性能达到预期。

通过良好的组件封装实践，可以提高代码的可维护性、可复用性和可测试性，加快开发速度，减少重复劳动，并提升整体的代码质量。

## 一、 什么是前端工程化

前端工程化是指将前端开发过程中的一系列流程和工具进行规范和自动化，从而提高开发效率、减少重复劳动、降低出错率。前端工程化的目标是让前端开发更高效、更优质。

### 1.1 前端工程化的定义

前端工程化是指在前端开发过程中，将前端开发的流程、工具和规范化，并使用相关技术实现自动化，包括但不限于代码编写、测试、构建、部署等环节，以提高前端开发效率、提高代码质量和可维护性。

### 1.2 为什么需要前端工程化

前端工程化能够极大地提高开发效率，提高代码质量和可维护性，减少出错率和重复工作。随着前端开发项目越来越复杂，需要开发的功能越来越多，手动进行前端开发将面临越来越大的挑战。
而采用前端工程化的方式，可以极大地减轻前端开发的工作负担，让开发人员更加专注于业务逻辑的开发。
![](https://cdn.nlark.com/yuque/0/2024/webp/29430977/1713759880716-505ccb61-1515-4317-9a7d-874aca1f382e.webp#averageHue=%23080706&clientId=u42c36c5f-8ae5-4&from=paste&id=uceb896b2&originHeight=810&originWidth=1440&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u934ab0ed-c2b5-4419-a9b5-cfc413998e5&title=)

## 二、 前端工程化的核心概念

前端工程化的核心概念包括模块化、打包构建、自动化部署、[自动化测试](https://www.zhihu.com/search?q=%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2925739518%7D)和持续集成等。

### 2.1 模块化

模块化是指将一个大的应用程序划分成多个小的模块，每个模块都有自己的功能和特点，可以独立开发、测试和维护。常见的模块化方案有 CommonJS、ES6 模块、AMD 等。

### 2.2 打包构建

打包构建是指将多个模块组合起来，生成可以在浏览器中运行的代码。打包构建的过程包括代码压缩、文件合并、资源管理等，常见的打包构建工具有 webpack、rollup 等。

### 2.3 自动化部署

自动化部署是指将打包构建后的代码部署到生产环境或测试环境中的自动化过程。自动化部署可以减少手动部署的错误和工作量，同时也可以缩短部署的时间。常见的自动化部署工具有 Jenkins、Travis CI 等。
![](https://cdn.nlark.com/yuque/0/2024/png/29430977/1713759880859-9e5176d2-289c-4a6b-9473-b3c004290ce3.png#averageHue=%23c0d7fc&clientId=u42c36c5f-8ae5-4&from=paste&id=ucef69a38&originHeight=501&originWidth=649&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u019b9af4-0b90-47c6-a2fa-954d2c65fae&title=)

### 2.4 自动化测试

前端工程化的另一个重要概念是自动化测试。自动化测试是指使用自动化工具对代码进行测试，以确保它们在开发过程中不会出现问题，并且在部署到生产环境之前也不会出现问题。
自动化测试可以分为两类：[单元测试](https://www.zhihu.com/search?q=%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2925739518%7D)和端到端测试。单元测试是指测试应用程序中最小的可测试单元，例如一个函数或一个类。端到端测试是指测试应用程序的整个流程，包括用户界面和后端逻辑。
自动化测试的优势在于它可以提高开发效率和代码质量。它可以帮助开发人员在更早的阶段发现问题，并且可以确保代码的正确性，减少代码中的错误和缺陷。

### 2.5 持续集成

持续集成是指在[应用程序开发](https://www.zhihu.com/search?q=%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2925739518%7D)过程中，将代码的改变频繁地集成到共享代码库中，并且每次集成都会进行自动化构建和自动化测试。这样可以确保代码的稳定性和质量，并且能够更快地检测和修复错误。
持续集成的优势在于它可以提高开发效率、加速代码部署和减少错误。它可以使团队更加协作，提高产品质量，并且可以更快地响应客户的需求。

### 2.6 前端工程化的主要工具

实现前端工程化需要使用多种工具。以下是一些常见的前端工程化工具：

- 包管理工具：npm、Yarn、Bower Pnpm
- 构建工具：Webpack、Vite , Rollup、Parcel、Gulp、Grunt
- 自动化测试工具：Jest、Mocha、Karma、Cypress、Puppeteer
- 集成工具：Travis CI、Jenkins、CircleCI、GitLab CI/CD、GitHub Actions

这些工具可以帮助开发人员自动化完成各种任务，如安装和管理依赖项、打包和压缩代码、运行自动化测试和部署代码。

## 三、你们之前公司的开发流程

1. 开项目评审会议，评审UI 和 需求可行性
2. 如果有前端项目架构，就从这个开始编写里面的具体功能点逻辑，没有就利用cli 新建基础项目，引入自己需要的库和工具类
3. 预估工时，预估UI设计还原度
4. 开发提供需求排期，项目经理新增需求跟踪，添加责任人测试对象
5. 根据需求和原型 设计抽象的组件，或者根据低代码平台去写基础逻辑
6. 每个需求设置具体的时间，到一定时间节点，提测，
7. 提供测试环境的地址给UI 和测试，去测试和评价需求和设计还原度
8. 功能提测

a. 开发环境自测结束，点击已完成，邮件，通知测试和项目经理UI
b. 测试通过，准备发版邮件，具体的描述，一般是后端发起，添加具体的SQL，执行的项目名称，分支或者tag名称，需求描述。
c. 运维接收到指令之后，构建项目
d. 运行无报错的情况下，通知测试，项目经理 UI 来验收
e. 项目经理 测试 UI 验收无误后，通知业务培训，并验收
然后依次执行这个流程

前端工程化在现代Web开发中已经成为标配。下面是一些常见的前端工程化方案：

- **前端模块化**：CommonJS、AMD、ES6模块化等
- **打包构建**：Webpack、Vite Rollup等
- **自动化部署：**Jenkins、Travis CI等
- **自动化测试：**Jest、Mocha、Karma等
- **持续集成：**Jenkins、Travis CI等
- **React项目的打包构建：**使用Webpack将多个模块打包成一个文件，并进行优化和压缩，减少页面加载时间和提高性能。
- **Vue.js项目的自动化部署**：使用Travis CI实现自动化测试和部署，自动构建并部署代码到服务器，减少手动操作，提高效率。
- **Angular项目的自动化测试：**使用Jest和Karma进行自动化测试，覆盖率高，能够及时发现代码中的问题，提高代码质量。

## 四、 如何学习前端工程化

1. 掌握基本的[前端技术](https://www.zhihu.com/search?q=%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2925739518%7D) 学习前端工程化需要先掌握一些基本的前端技术，如HTML、CSS、JavaScript等，这些技术是前端工程化的基础。
2. 学习相关的工具和框架 学习前端工程化需要了解一些相关的工具和框架，如Webpack、Rollup、Jenkins、Travis CI、Jest、Mocha、Karma等，可以通过官方文档、博客、视频教程等途径进行学习。
3. 多做实战项目，加深理解 学习前端工程化需要多做实战项目，通过实践加深对前端工程化的理解和掌握。可以从简单的项目入手，逐步提升自己的技能和能力。

## 五、总结：

前端工程化是现代前端开发的标配，通过模块化、打包构建、自动化部署、自动化测试和持续集成等解决方案，可以提高开发效率、代码质量和团队协作效率，降低开发成本。
掌握前端工程化需要先掌握基本的前端技术，然后学习相关的工具和框架，多做实战项目进行实践，才能不断提提升。
Vite是什么？Rollup是什么？
是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。在生产环境下使用Rollup打包

### [#](https://interview.poetries.top/docs/excellent-docs/9-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%9D%97.html#vite-%E7%89%B9%E7%82%B9)Vite 特点

- Dev Server 无需等待，即时启动；
- 几乎实时的模块热更新；
- 所需文件按需编译，避免编译用不到的文件；
- 开箱即用，避免各种 Loader 和 Plugin 的配置；

**开箱即用**

- TypeScript - 内置支持
- less/sass/stylus/postcss - 内置支持（需要单独安装所对应的编译器）

**生产环境需要打包吗**
可以不打包，需要启动server，需要浏览器支持
![](https://cdn.nlark.com/yuque/0/2024/png/29430977/1713763791902-59b2a962-6cf0-4451-b830-eb9227114226.png#averageHue=%23f1f1f1&clientId=u42c36c5f-8ae5-4&from=paste&id=u17bb160d&originHeight=426&originWidth=1212&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud0bd4205-5582-41f9-a404-45361fa8c42&title=)

### [#](https://interview.poetries.top/docs/excellent-docs/9-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%9D%97.html#vite-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%90%AF%E5%8A%A8%E9%9D%9E%E5%B8%B8%E5%BF%AB)Vite 为什么启动非常快

- 开发环境使用Es6 Module，无需打包，非常快
- 生产环境使用rollup，并不会快很多

## webpack ?

### 核心概念

JavaScript 的 模块打包工具 (module bundler)。通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包 (bundler)，供 HTML 直接引用。实质上，Webpack 仅仅提供了 打包功能 和一套 文件处理机制，然后通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包。因此 Webpack 具有高度的可拓展性，能更好的发挥社区生态的力量。

- Entry: 入口文件，Webpack会从该文件开始进行分析与编译；
- Output: 出口路径，打包后创建 bundler的文件路径以及文件名；
- Module: 模块，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包；
- Chunk: 代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能；
- Loader: 模块加载器，进行各种文件类型的加载与转换；
- Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改；

### [#](https://interview.poetries.top/docs/excellent-docs/9-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%9D%97.html#_1-2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E5%8A%A0%E8%BD%BD-%E7%BC%96%E8%AF%91-%E8%BE%93%E5%87%BA)1.2 工作流程 (加载 - 编译 - 输出)

1. 读取配置文件，按命令 初始化 配置参数，创建 Compiler 对象；
2. 调用插件的 apply 方法 挂载插件 监听，然后从入口文件开始执行编译；
3. 按文件类型，调用相应的 Loader 对模块进行 编译，并在合适的时机点触发对应的事件，调用 Plugin 执行，最后再根据模块 依赖查找 到所依赖的模块，递归执行第三步；
4. 将编译后的所有代码包装成一个个代码块 (Chuck)， 并按依赖和配置确定 输出内容。这个步骤，仍然可以通过 Plugin 进行文件的修改;
5. 最后，根据 Output 把文件内容一一写入到指定的文件夹中，完成整个过程；

### 1.3 模块包装

```javascript
(function (modules) {
  // 模拟 require 函数，从内存中加载模块；
  function __webpack_require__(moduleId) {
    // 缓存模块
    if (installedModules[moduleId])
      return installedModules[moduleId].exports

    const module = (installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {},
    })

    // 执行代码；
    modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    )

    // Flag: 标记是否加载完成；
    module.l = true

    return module.exports
  }

  // ...

  // 开始执行加载入口文件；
  return __webpack_require__((__webpack_require__.s = './src/index.js'))
})({
  './src/index.js': function (
    module,
    __webpack_exports__,
    __webpack_require__
  ) {
    // 使用 eval 执行编译后的代码；
    // 继续递归引用模块内部依赖；
    // 实际情况并不是使用模板字符串，这里是为了代码的可读性；
    eval(`
			__webpack_require__.r(__webpack_exports__);
			//
			var _test__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("test", ./src/test.js");
		`)
  },
  './src/test.js': function (module, __webpack_exports__, __webpack_require__) {
    // ...
  },
})
```

**总结:**

- **模块机制**: webpack自己实现了一套模拟模块的机制，将其包裹于业务代码的外部，从而提供了一套模块机制；
- **文件编译**: webpack 规定了一套编译规则，通过 Loader 和 Plugin，以管道的形式对文件字符串进行处理；

### [#](https://interview.poetries.top/docs/excellent-docs/9-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%9D%97.html#_1-4-webpack%E7%9A%84%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86)1.4 webpack的打包原理

- 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
- 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
- 确定入口：根据配置中的 entry 找出所有的入口文件
- 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
- 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
- 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
- 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

### [#](https://interview.poetries.top/docs/excellent-docs/9-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%9D%97.html#_1-5-webpack%E7%9A%84%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86)1.5 webpack的打包原理详细

**相关问题**

- webpack 工作流程是怎样的
- webpack 在不同阶段做了什么事情

webpack 是一种模块打包工具，可以将各类型的资源，例如图片、CSS、JS 等，转译组合为 JS 格式的 bundle 文件
**webpack 构建的核心任务是完成内容转化和资源合并。主要包含以下 3 个阶段：**

1. 初始化阶段

- **初始化参数**：从配置文件、配置对象和 Shell 参数中读取并与默认参数进行合并，组合成最终使用的参数
- **创建编译对象**：用上一步得到的参数创建 Compiler 对象。
- **初始化编译环境**：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等

1. 构建阶段

- **开始编译**：执行 Compiler 对象的 run 方法，创建 Compilation 对象。
- **确认编译入口**：进入 entryOption 阶段，读取配置的 Entries，递归遍历所有的入口文件，调用 Compilation.addEntry 将入口文件转换为 Dependency 对象。
- **编译模块（make）**： 调用 normalModule 中的 build 开启构建，从 entry 文件开始，调用 loader 对模块进行转译处理，然后调用 JS 解释器（acorn）将内容转化为 AST 对象，然后递归分析依赖，依次处理全部文件。
- **完成模块编译**：在上一步处理好所有模块后，得到模块编译产物和依赖关系图

1. 生成阶段

- **输出资源（seal）**：根据入口和模块之间的依赖关系，组装成多个包含多个模块的 Chunk，再把每个 Chunk 转换成一个 Asset 加入到输出列表，这步是可以修改输出内容的最后机会。
- **写入文件系统（emitAssets）**：确定好输出内容后，根据配置的 output 将内容写入文件系统

### webpack 为什么比vite 慢

### [vite为什么比webpack快](http://www.baidu.com/link?url=hMQMDIFbXSPTsTkYajONhkS9Ug2YaAZddgF98sFALkElpZXGvLtO1rOJLZDumUQleFvlsZ89SbaSTeZzeN6X5OZCh8N2JtfNRKAgCA_rv9eReOIx8_DABQejqmF7Blto_jubGQ0rinkv_y2JjFCAQuPI1YGnmTvyQeIY-0NEJyQzV6rJH6kpA5DHQNe2b03xV38jNxKQQ4YLSXS9iMQHPK83TAIi79ChwkAuSn94B-8YDmujfiHcH-wK1mh9dPgeMlJXCUm1bW1QShMv95c6mnpfkaPhQt7xXz4kfgE7B2QUwdrLvML2fmhTNBFRFpZXY0V0_gWds0YVT3BOU_qLPR1uESM7qPBeOQLEUan_KoBWaCvPAPrsLJglUpqgshHxUI-h0P0YlFVtTr-opFEuuSiPeHcAGR4PuDlYW9kq4zzlCarNqmtCJ6TD89DVyhgstslsO0fE4dyI61gU9WLX8C6VmdCzVzbLLrVHaiAoaLwUJcQajCwxVHseF0QESyMg9Y9n6zj-IhtF_FGv5iCxtOqmQTiV-YFZqQBBQY0uTzC)

Vite比Webpack快的主要原因包括开发模式的差异、对[ES Module](https://www.baidu.com/s?wd=ES%20Module&usm=1&ie=utf-8&rsv_pq=bfaa9e20031f14ad&oq=vite%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94webpack%E5%BF%AB&rsv_t=73c4oJXJl6N8Mzvv1egbG4fxOwwKpfFwUc35qiKcnahPmCN0m892d%2BQjvts&sa=re_dqa_zy&icon=1)的支持、底层语言的差异、启动速度和热更新等方面。具体说明如下：12

- 开发模式差异。Webpack在开发环境中先打包再启动开发服务器，而Vite直接启动开发服务器，按需编译依赖文件。这意味着Vite不需要像Webpack那样在开发前打包所有模块，从而减少了启动时间和构建时间。
- ES Module支持。Vite利用现代浏览器支持ES Modules的特性，直接将模块文件作为浏览器要执行的文件，而不是像Webpack那样先打包再执行。这种做法减少了中间环节，提高了效率。
- 底层语言差异。Vite使用esbuild进行预构建依赖，esbuild是用Go语言编写的，而Webpack基于Node.js。Go语言运行速度快，使得Vite在打包速度上有显著提升。**webpack是毫秒级 go是纳米级别。**
- 启动速度和热更新。Vite在启动时不需要打包，因此启动速度快。当模块内容改变时，Vite可以快速进行热更新，仅重新请求改动过的模块，而不是像Webpack那样重新编译所有依赖模块。
- 关注层级不同。Vite关注的是如何快速方便地搭建项目，减少了配置量，而Webpack更关注功能的实现和构建细节。

总的来说，Vite通过其独特的开发模式、对ES Module的有效利用、底层语言的优化以及快速的热更新机制，实现了比Webpack更快的开发体验。

## 前端打包工具rollup、webpack、vite的区别

rollup更适合打包库，webpack更适合打包项目，vite基于rollup实现了热更新也适合打包项目。

rollup基于esm打包，打包生成的文件更小。（识别commonJs需要插件）
rollup原生支持tree-shaking，webpack2开始支持且消除效果不好。（去除未使用代码）
webpack支持代码切割。（分包）
webpack支持HMR。（热更新）。
vite在生产环境通过rollup进行打包（打包体积小），生成esm模块包。（快）
vite在开发环境时，基于浏览器支持esm，让浏览器解析模块，然后服务器按需编译返回。同时基于esbuild（go）进行预构建打包不常变动的第三包，并用进行缓存。（缓存+快）
vite热更新，实现按需编译，按模块更新。webpack需要全部重新编译并更新。（快）
** webpack**
**1. 核心概念**
入口(entry)：webpack构建入口配置
输出(output)：webpack构建完输出文件配置
loader：webpack只能分析js文件，需要使用loader转化为js文件。
style-loader：实现js添加style标签
css-loader：允许js使用import 引入css文件
babel-loader：es6 - es5

插件(plugins)：扩展webpack的能力
html-webpack-plugin：指定模板打包
extract-text-webpack-plugin/mini-css-extract-plugin：将css独立打包成一个文件
webpack-dev-server：实现开发服务器
** 重要概念**
**模式(mode)：**development/production
**模块(modules)：**webpack中每个文件都是一个模块
**runtime：**在模块交互时，连接模块所需的加载和解析逻辑，作用是为了线上更新版本时，充分利用浏览器缓存，使用户感知的影响到最低
**manifest：**保存打包后的代码的映射，提供给runtime使用
**热更新(HMR) ：**在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面 — 实现插件webpack-dev-server ，和webpack.HotModuleReplacementPlugin 一起实现热更新

# 项目开发中的dev，test，prod，sit，uat，pre，fat 对应含义

dev：开发环境。用于开发者调试使用。开发环境是程序猿们专门用于开发的服务器，配置可以比较随意，为了开发调试方便，一般打开全部错误报告。
test：测试环境。一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。
prod：生产环境。正式线上环境。是值正式提供对外服务的，一般会关掉错误报告，打开错误日志。通常说的真实环境。
sit：系统集成测试。
uat：用户验收测试环境。生产环境下的软件测试者测试使用。预发布环境。
pre：灰度环境。灰度测试环境就是生产环境，生产数据，所影响的也是生产环境，只是范围比测试环境更广，更真实。其实就是小范围的生产环境。类似于游戏内测。
fat：功能验收测试环境。软件测试者测试使用。

### javascipt 脚本延迟加载的方式有那些？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712635749479-c781acf3-8897-4816-bcb3-568664d0cf27.png#averageHue=%23373d4a&clientId=uec73d81c-e9dd-4&from=paste&height=471&id=r4ziV&originHeight=706&originWidth=910&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=664282&status=done&style=none&taskId=u92267482-a08a-4abd-ab97-60e438e1cdf&title=&width=606.6666666666666)

### javascript有哪些数据类型，他们的区别

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712636074424-e561032c-4c39-4b57-9ec7-7baff7bc5180.png#averageHue=%23393e4b&clientId=uec73d81c-e9dd-4&from=paste&height=461&id=u2d2faa5e&originHeight=691&originWidth=909&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=456462&status=done&style=none&taskId=u89bc037c-079e-4a85-999d-a0234c45151&title=&width=606)

### null 和undefined的区别

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712636141082-885d15bb-df77-420a-b288-b00448e0e58e.png#averageHue=%23353a47&clientId=uec73d81c-e9dd-4&from=paste&height=518&id=u753cac75&originHeight=777&originWidth=910&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=500668&status=done&style=none&taskId=u8462fe80-e634-4899-bbbd-b28c48a453e&title=&width=606.6666666666666)

### 对JSON 如何理解

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712636188805-4e9b889b-69e2-485d-88f0-9cf820f3a5db.png#averageHue=%23393f4c&clientId=uec73d81c-e9dd-4&from=paste&height=514&id=ufa2d6a1d&originHeight=771&originWidth=783&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=806340&status=done&style=none&taskId=ubb908d29-7b47-42f2-81bd-9dc35578a9a&title=&width=522)

### 如何判断一个对象是空对象

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712636237634-81e7084c-cb74-4390-84d8-dbedf61166fa.png#averageHue=%23303643&clientId=uec73d81c-e9dd-4&from=paste&height=457&id=u1b235fd5&originHeight=685&originWidth=802&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=282040&status=done&style=none&taskId=u26501586-fc4f-4d95-9b8d-33ba33ae65e&title=&width=534.6666666666666)

### 防盗链是什么，怎么实现

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712636260908-05cc7b06-41ad-496d-9aee-c4467b14d144.png#averageHue=%23e5e4df&clientId=uec73d81c-e9dd-4&from=paste&height=495&id=u778df25d&originHeight=742&originWidth=915&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=846070&status=done&style=none&taskId=u4df274cd-29f7-4020-b5f3-c82680bba55&title=&width=610)

### 关于前端安全方面，了解过那些？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712636442996-97daced9-c32e-4252-b0d9-a2ac7f18676b.png#averageHue=%23dfddd8&clientId=uec73d81c-e9dd-4&from=paste&height=535&id=u41735dc8&originHeight=802&originWidth=913&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=832015&status=done&style=none&taskId=ufe762512-3f87-4e88-a2c9-8377aa1d340&title=&width=608.6666666666666)

### 前端的加密方式，你知道那些？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712636751449-8d5d876f-15e6-43f3-9814-dabcacb98ee5.png#averageHue=%23e5e3df&clientId=uec73d81c-e9dd-4&from=paste&height=477&id=u8731ae76&originHeight=715&originWidth=912&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=753123&status=done&style=none&taskId=uc0a02517-8575-4569-ac17-95c03c16f23&title=&width=608)

### 前端如何防止用户重复提交？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712636809229-192fc042-749f-4dda-bc4f-8a8752ab3818.png#averageHue=%23e7e6e0&clientId=uec73d81c-e9dd-4&from=paste&height=529&id=ud304c090&originHeight=793&originWidth=913&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=812485&status=done&style=none&taskId=u0225381f-5af1-4907-bf9e-fdef245a490&title=&width=608.6666666666666)

### 说一下浏览器的本地存储？

## ![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712637245454-3d9c207e-bcc5-48b1-8b3e-29168168918e.png#averageHue=%23e7e6e0&clientId=uec73d81c-e9dd-4&from=paste&height=521&id=JxAoI&originHeight=781&originWidth=915&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=842621&status=done&style=none&taskId=u7e83c7fe-7134-4b3e-a54a-2bdea300c63&title=&width=610)

## 团队合作中，如何进行前端代码的规范和代码质量的保证？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712634979671-33b8af29-ebf0-421b-ae08-b6ed5ba6cb7e.png#averageHue=%23e5e3de&clientId=uec73d81c-e9dd-4&from=paste&height=583&id=u8958f4ff&originHeight=874&originWidth=1054&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=1012889&status=done&style=none&taskId=u86d58a63-929a-4b79-affe-eb9b69a329c&title=&width=702.6666666666666)

### 在项目中，如何处理大规模数据的渲染和性能优化？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712635100519-adc85250-69a0-4579-8c40-2efe576145c6.png#averageHue=%23e3e2dd&clientId=uec73d81c-e9dd-4&from=paste&height=503&id=uc768abdd&originHeight=754&originWidth=958&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=800773&status=done&style=none&taskId=uc2356b8a-e8f8-490d-9d1e-77984bf514d&title=&width=638.6666666666666)

### 在移动端开发中，如何保证网页在不同的设备和不同浏览器上的兼容性？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712635313615-e86551a0-087d-40ea-b9f1-cb0cac689bcc.png#averageHue=%23e6e4df&clientId=uec73d81c-e9dd-4&from=paste&height=545&id=u36df0cce&originHeight=817&originWidth=990&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=927759&status=done&style=none&taskId=u65c3b890-512d-4aff-aeef-8082788f0e5&title=&width=660)

### 在移动端开发中，如何实现用户登录和权限验证？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712635463073-4adbe188-8a5e-4835-a9c2-858b740bee0b.png#averageHue=%23e7e6e1&clientId=uec73d81c-e9dd-4&from=paste&height=479&id=ua83ae9af&originHeight=718&originWidth=919&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=895360&status=done&style=none&taskId=u4856dee8-7513-462f-8e19-075ffcc1a8e&title=&width=612.6666666666666)

## 九、HR

### 1.你的离职原因是什么？

疫情 社保 薪资问题 个人发展 技术提升 家庭因素

### 2.工作到现在，项目中遇到最难的问题是什么？怎么解决的？

1.不要回答，没有问题
       2.不要说一些常见的简单的问题，比如：数据请求不过来、渲染页面时出现了问题、跳转路由不会...
       首先应该时自行去查找资料寻求解决办法，然后再去请教同时或者组长

### 3.你的优势在哪里？

1.尽量不要暴露自己的缺点
       2.不要过度美化自己

### 4.如何协同工作？

1.开发前会开个会议，最后形成一个开发文档
       2.利用工具保证项目的正常进度，规范化 **Jira 禅道 Teambition**

### 如何通过实践项目来提升自己的前端技能

### js面试题：循环语句中while和do...while的区别

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712642265485-f401b8ad-e2ae-4fd8-80ce-eafaf338c8a1.png#averageHue=%23ececec&clientId=uec73d81c-e9dd-4&from=paste&height=83&id=ubc15a227&originHeight=124&originWidth=582&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20602&status=done&style=none&taskId=u494ce99c-9104-4942-9730-2b05e0480af&title=&width=388)

### vue3中如何实现一个组件的异步加载？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712642288897-c30db774-92bb-4192-bb27-a98a56754027.png#averageHue=%23383c41&clientId=uec73d81c-e9dd-4&from=paste&height=153&id=uf4a2b1c8&originHeight=229&originWidth=897&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=127777&status=done&style=none&taskId=uccf17d44-c816-4d17-b573-e11897b216c&title=&width=598)

### css面试题：浮动元素会造成什么样的影响？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712642306423-313c41f4-8565-4bd0-8e75-c8cbe0e2f2bc.png#averageHue=%23848b82&clientId=uec73d81c-e9dd-4&from=paste&height=475&id=u80e1aa04&originHeight=712&originWidth=931&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=204963&status=done&style=none&taskId=u18e38c27-b455-43c9-a83f-e02e2fbb977&title=&width=620.6666666666666)

### vue面试题：computed，methods,watch有什么区别？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712642371425-b26733b0-c97c-486d-902b-4c4176ebc62b.png#averageHue=%23c3c7c6&clientId=uec73d81c-e9dd-4&from=paste&height=177&id=ud5259d76&originHeight=265&originWidth=1180&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=191324&status=done&style=none&taskId=u4f846528-2990-4906-a82a-4cec705b813&title=&width=786.6666666666666)

### vue面试题：props和data优先级谁高？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712642165071-31c635fb-dd07-489a-b722-28b8995011e2.png#averageHue=%23f2f2f2&clientId=uec73d81c-e9dd-4&from=paste&height=65&id=u6fdd1135&originHeight=97&originWidth=885&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=22337&status=done&style=none&taskId=u18bc35bc-b3f5-40db-a3cf-d48099a0078&title=&width=590)

## vuex面试题

### promise如何一次进行多个异步请求？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712642831021-94f7eae9-9492-47c8-b304-4ae72111005d.png#averageHue=%23ececeb&clientId=uec73d81c-e9dd-4&from=paste&height=503&id=uc30b7e62&originHeight=754&originWidth=889&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=443318&status=done&style=none&taskId=u394f2fb6-4e30-4a17-92b7-d90ad960346&title=&width=592.6666666666666)

### csrf和xss是什么，如何避免？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712643006928-257bae58-eccf-4de4-8d96-4244b223c3c0.png#averageHue=%23e9e6de&clientId=uec73d81c-e9dd-4&from=paste&height=148&id=ucb12faa3&originHeight=222&originWidth=886&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=187687&status=done&style=none&taskId=u24925179-60a6-4cba-8387-6cf55bc3bf1&title=&width=590.6666666666666)

### 前端怎样对用户的数据进行加密传输？

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29430977/1712643157787-1bf79a29-3d3c-4e6e-9e4c-6f74bb2874f9.png#averageHue=%23f8f7f7&clientId=uec73d81c-e9dd-4&from=paste&height=261&id=u401a5fa9&originHeight=391&originWidth=802&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=164853&status=done&style=none&taskId=udd9da791-202f-4cef-a56d-bf9f32b1b59&title=&width=534.6666666666666)

### 如何高效的筛选和申请合适的前端开发职位？

### 在面试过程中，如何展示出除技术能力之外的其他软实力？

### 在职业规划师，前端开发展在求职过程中如何解决未来发展空间的问题？
